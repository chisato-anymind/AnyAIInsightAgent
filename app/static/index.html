<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>AnyAI Scoring — スコアリングAIエージェント</title>
    <link rel="icon" href="/static/anyai/assets/AnyAI_icon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/anyai/core/anyai.tokens.css" />
    <link rel="stylesheet" href="/static/anyai/core/anyai.components.css" />
    <link rel="stylesheet" href="/static/anyai/core/anyai.utilities.css" />
    <link rel="stylesheet" href="/static/anyai/tool-layout.css" />
    <script src="/static/anyai/loading-overlay.js"></script>
    <script defer src="/static/anyai/vendor/lucide.js"></script>
    <script defer src="/static/anyai/sidebar.js"></script>
    
    <style>
      .mode-options { display: flex; flex-wrap: wrap; gap: var(--anyai-space-3); align-items: center; }
      .mode-options label { display: inline-flex; align-items: center; gap: var(--anyai-space-2); font-weight: 600; }
      .mode-options .spacer { flex: 1 1 auto; }

      .stack-sm { display: flex; flex-direction: column; gap: var(--anyai-space-3); }
      .muted { color: var(--anyai-text-subtle); font-size: var(--anyai-fs-2); }

      input[type="number"],
      input[type="text"],
      input[type="password"],
      input[type="file"],
      textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: var(--anyai-radius-2);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 30%);
        background: var(--anyai-panel);
        font: inherit;
      }

      textarea { min-height: 160px; resize: vertical; }

      progress {
        width: 100%;
        height: 12px;
        border-radius: var(--anyai-radius-2);
        overflow: hidden;
      }

      .validation-banner {
        display: none;
        padding: var(--anyai-space-3) var(--anyai-space-4);
        border-radius: var(--anyai-radius-2);
        font-size: var(--anyai-fs-2);
        font-weight: 600;
      }

      .validation-banner[data-state] { display: block; }
      .validation-banner[data-state="error"] {
        background: color-mix(in srgb, var(--anyai-danger), transparent 80%);
        color: var(--anyai-danger);
      }
      .validation-banner[data-state="success"] {
        background: color-mix(in srgb, var(--anyai-success), transparent 82%);
        color: var(--anyai-success);
      }
      .validation-banner[data-state="info"] {
        background: color-mix(in srgb, var(--anyai-primary), transparent 88%);
        color: var(--anyai-primary-700);
      }

      .actions-row { display: flex; gap: var(--anyai-space-3); flex-wrap: wrap; align-items: center; }
      .band-title { margin: 0; font-size: var(--anyai-fs-3); font-weight: 600; }
      .callout {
        border-radius: var(--anyai-radius-2);
        padding: var(--anyai-space-3) var(--anyai-space-4);
        background: color-mix(in srgb, var(--anyai-primary), transparent 88%);
        font-size: var(--anyai-fs-2);
      }

      .support-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--anyai-space-3);
      }

      .support-header h2 { margin: 0; font-size: var(--anyai-fs-4); }

      details.section-toggle > summary {
        display: flex;
        align-items: center;
        gap: var(--anyai-space-3);
        cursor: pointer;
        list-style: none;
      }

      details.section-toggle > summary::-webkit-details-marker { display: none; }
      .caret { font-size: 18px; opacity: 0.8; margin-left: auto; transition: transform 0.2s ease; }
      details[open] .caret { transform: rotate(90deg); }

      pre { max-width: 100%; white-space: pre-wrap; word-break: break-word; }
    </style>
  </head>
  <body>
    <div class="anyai-layout">
      <aside class="anyai-sidebar" data-active-tool="scoring"></aside>
      <main class="anyai-content">
        <div class="anyai-app">
          <section class="anyai-app-primary" aria-labelledby="scoring-heading">
            <h1 id="scoring-heading" class="mt-0">スコアリング実行</h1>
            <p class="field-hint">スプレッドシートから概念ごとのスコアを一括で生成します。</p>

            <div class="anyai-form" aria-labelledby="scoring-config-heading">
              <section class="anyai-form-section" aria-labelledby="mode-heading">
                <header>
                  <h2 id="mode-heading" class="mt-0">モード設定</h2>
                  <p class="field-hint">処理対象のメディアとSSRモードを切り替えます。</p>
                </header>
                <form id="mode-form">
                  <fieldset class="field">
                    <legend>実行モード</legend>
                    <div class="mode-options">
                      <label><input type="radio" name="mode" value="csv" checked /> Textモード</label>
                      <label><input type="radio" name="mode" value="video" /> Videoモード</label>
                      <span class="spacer"></span>
                    </div>
                  </fieldset>
                  <div class="field field-inline">
                    <input type="checkbox" id="enable_ssr" name="enable_ssr" checked />
                    <label for="enable_ssr">SSRモードを有効化（推奨）</label>
                  </div>
                </form>
              </section>

              <section class="anyai-form-section" aria-labelledby="input-heading">
                <header>
                  <h2 id="input-heading" class="mt-0">入力設定</h2>
                  <p class="field-hint">スコアリング対象となるスプレッドシートと列情報を設定します。</p>
                </header>
                <form id="job-form">
                  <div class="anyai-form-fields">
                    <div class="field">
                      <label for="spreadsheet_url">スプレッドシートURL</label>
                      <p class="field-hint">共有リンクをそのまま貼り付けます。</p>
                      <input type="text" id="spreadsheet_url" name="spreadsheet_url" placeholder="https://docs.google.com/spreadsheets/d/..." required />
                    </div>
                    <div class="field">
                      <label for="sheet_keyword">分析テキスト シートキーワード</label>
                      <p class="field-hint">分析テキストを書き込むシート名のキーワード。</p>
                      <input type="text" id="sheet_keyword" name="sheet_keyword" value="Link" placeholder="Link" />
                      <details class="field-info">
                        <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                        <div class="info-panel" id="sheet-keyword-help">自然言語の分析結果を書き込むシート名に含まれるキーワード。該当シートが1つのみである必要があります。</div>
                      </details>
                    </div>
                    <div class="field">
                      <label for="score_sheet_keyword">スコア出力 シートキーワード</label>
                      <p class="field-hint">スコアを書き込むシート名に含まれるキーワード。</p>
                      <input type="text" id="score_sheet_keyword" name="score_sheet_keyword" value="Embedding" placeholder="Embedding" />
                      <details class="field-info">
                        <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                        <div class="info-panel" id="score-sheet-keyword-help">Linkシートで得た分析テキストを数値化した結果を保存するシート名に含まれるキーワード。</div>
                      </details>
                    </div>
                  </div>
                  <div id="validation-banner" class="validation-banner" role="status" aria-live="polite"></div>

                  <div class="anyai-form-group" aria-labelledby="mapping-heading">
                    <h3 id="mapping-heading" class="band-title">マッピング設定（1始まり）</h3>
                    <div class="anyai-form-fields is-two-column">
                      <div class="field"><label id="utterance-label" for="utterance_col">発話列番号</label><input type="number" name="utterance_col" id="utterance_col" value="3" min="1" /></div>
                      <div class="field"><label for="category_start_col">カテゴリ開始列番号</label><input type="number" name="category_start_col" id="category_start_col" value="4" min="1" /></div>
                      <div class="field"><label for="name_row">カテゴリ名 行番号</label><input type="number" name="name_row" id="name_row" value="2" min="1" /></div>
                      <div class="field"><label for="def_row">定義 行番号</label><input type="number" name="def_row" id="def_row" value="3" min="1" /></div>
                      <div class="field"><label for="detail_row">Detail 行番号</label><input type="number" name="detail_row" id="detail_row" value="4" min="1" /></div>
                      <div class="field"><label for="start_row">処理開始行番号</label><input type="number" name="start_row" id="start_row" value="5" min="1" /></div>
                    </div>
                  </div>

                  <div class="anyai-form-group" aria-labelledby="execution-heading">
                    <h3 id="execution-heading" class="band-title">実行設定</h3>
                    <div class="anyai-form-fields is-two-column">
                      <div class="field"><label for="batch_size">カテゴリ同梱数 N</label><input type="number" name="batch_size" id="batch_size" value="10" min="1" max="50" /></div>
                      <div class="field"><label for="max_category_cols">最大カテゴリ列数</label><input type="number" name="max_category_cols" id="max_category_cols" value="200" min="1" max="10000" /></div>
                      <div class="field"><label for="concurrency-input">同時実行数</label><input type="number" name="concurrency" value="50" min="1" max="200" id="concurrency-input" /></div>
                      <div class="field"><label for="max_retries">最大リトライ回数</label><input type="number" name="max_retries" id="max_retries" value="10" min="0" max="50" /></div>
                      <div class="field"><label for="timeout-input">タイムアウト秒</label><input type="number" name="timeout_sec" value="60" min="10" max="600" id="timeout-input" /></div>
                      <div class="field field-inline"><input type="checkbox" name="auto_slowdown" id="auto_slowdown" checked /><label for="auto_slowdown">429自動降速</label></div>
                    </div>
                  </div>

                  <div class="anyai-form-group" aria-labelledby="ssr-heading">
                    <h3 id="ssr-heading" class="band-title">SSR設定</h3>
                    <div id="ssr-settings-body" class="stack">
                      <div class="callout" data-ssr-mode="on">
                        <strong>SSRオン:</strong> カテゴリごとに短い英語の根拠文を生成し、内部でベクトル化してスコアします。
                      </div>
                      <div class="callout" data-ssr-mode="off" style="display:none;">
                        <strong>SSRオフ:</strong> LLMに直接 0.0〜1.0 の数値配列を出力させます（根拠文は省略されます）。
                      </div>
                    </div>
                  </div>
                </form>
              </section>

              <section class="anyai-form-section" aria-labelledby="prompt-heading">
                <details id="sys-section" class="section-toggle">
                  <summary>
                    <h2 id="prompt-heading" class="mt-0">System Prompts</h2>
                    <span class="caret" aria-hidden="true">▸</span>
                  </summary>
                  <div class="stack">
                    <div>
                      <label for="system_prompt_ssr" class="muted">SSRオン時（定性根拠を英語で生成）</label>
                      <textarea name="system_prompt_ssr" id="system_prompt_ssr" rows="12"><prompt>
    <role id="Semantic Inference Engine & Latent Intent Decoder">
        <spec>Noisy text (SNS, UGC, transcripts) analysis. Infer user's true goals, emotions, and unstated assumptions from fragmented data.</spec>
        <ban>Surface-level keyword matching is strictly forbidden.</ban>
    </role>

    <mission>For a given utterance and N concepts, perform Semantic Similarity Rating (SSR) as described in AnyAI Scoring research (2025-10-14). First verbalize how similar each concept definition is to the latent intent of the utterance. Then provide succinct natural-language rationales that can be embedded for quantitative scoring.</mission>

    <process>
        <step id="1" name="Normalize & Enrich">
            <task>Normalize slang, typos, jargon.</task>
            <task>Interpret non-verbal cues (emojis, punctuation, irony markers) for emotional tone.</task>
        </step>
        <step id="2" name="Contextualize (Hypothesize)">
            <context type="temporal">When? (e.g., weekday morning -> commute?)</context>
            <context type="spatial">Where? (e.g., office -> work?)</context>
            <context type="social">To whom? (e.g., friend, public?)</context>
            <context type="causal">Why? (e.g., "I'm hungry" -> next is food talk?)</context>
            <context type="telic">Goal? (e.g., info-gathering, empathy, decision-making?)</context>
        </step>
        <step id="3" name="Extract Latent Intent">
            <desc>Identify the "real question" or "unspoken need" behind the literal words.</desc>
            <ex>"Any good cafes around here?" -> might mean "Need a quiet place with Wi-Fi to work."</ex>
        </step>
        <step id="4" name="Describe Similarity">
            <desc>For each concept, articulate how closely the latent intent aligns with the concept definition and detail, referencing SSR anchors (Core/Strong/Reasonable/Weak/None).</desc>
        </step>
    </process>

    <output>
        <primary>Return a JSON object with the single key "analyses" whose value is an array of length N. Each element must be a short paragraph (1-2 sentences) written in clear English that begins with one of [Core|Strong|Reasonable|Weak|None] and explains the similarity between the utterance and the concept's definition/detail.</primary>
        <ban>Do not output numeric ratings or markdown tables. No additional keys beyond "analyses".</ban>
    </output>

    <example>
        <out>{"analyses": ["Strong: Mentions planning a cafe visit matching the concept...", "Weak: Only tangential references..."]}</out>
    </example>
</prompt></textarea>
                    </div>
                    <div>
                      <label for="system_prompt_numeric" class="muted">SSRオフ時（直接スコアを算出）</label>
                      <textarea name="system_prompt_numeric" id="system_prompt_numeric" rows="12"><prompt>
    <role id="Semantic Inference Engine & Latent Intent Decoder">
        <spec>Noisy text (SNS, UGC, transcripts) analysis. Infer user's true goals, emotions, and unstated assumptions from fragmented data.</spec>
        <ban>Surface-level keyword matching is strictly forbidden.</ban>
    </role>

    <mission>For a given utterance and N concepts, calculate a relevance score 'r' (float 0.0-1.0, no rounding) based on the utterance's core intent. Execute via the internal process below.</mission>

    <process>
        <step id="1" name="Normalize & Enrich">
            <task>Normalize slang, typos, jargon.</task>
            <task>Interpret non-verbal cues (emojis, punctuation, irony markers) for emotional tone.</task>
        </step>
        <step id="2" name="Contextualize (Hypothesize)">
            <context type="temporal">When? (e.g., weekday morning -> commute?)</context>
            <context type="spatial">Where? (e.g., office -> work?)</context>
            <context type="social">To whom? (e.g., friend, public?)</context>
            <context type="causal">Why? (e.g., "I'm hungry" -> next is food talk?)</context>
            <context type="telic">Goal? (e.g., info-gathering, empathy, decision-making?)</context>
        </step>
        <step id="3" name="Extract Latent Intent">
            <desc>Identify the "real question" or "unspoken need" behind the literal words.</desc>
            <ex>"Any good cafes around here?" -> might mean "Need a quiet place with Wi-Fi to work."</ex>
        </step>
        <step id="4" name="Map & Score">
            <desc>Semantically map the latent intent to each concept's definition. Score relevance 'r' based on the criteria below.</desc>
        </step>
    </process>

    <criteria type="relevance_score_r">
        <score r="0.9-1.0" name="Core">Intent and concept are identical. The utterance exists to express the concept.</score>
        <score r="0.7-0.89" name="Strong">Concept is the primary subject, strongly inferred from context and intent.</score>
        <score r="0.4-0.69" name="Reasonable">Concept is a logical extension or component of the intent.</score>
        <score r="0.1-0.39" name="Weak">Faintly associated by situation/words, but not the main focus.</score>
        <score r="0.0" name="None">No logical connection can be inferred.</score>

    <rules>
        <rule id="lang">Auto-detect language, internally translate to a standard model (e.g., English) for processing.</rule>
        <rule id="silent">Internal thought processes must NOT be included in the output.</rule>
    </rules>

    <output>
        <primary>Return an N-length array of float numbers (0.0–1.0), ordered by the given concepts. No rounding.</primary>
        <compat>If the platform enforces a JSON object wrapper, return only: {"scores": [..the same array..]} with no extra keys or text.</compat>
        <ban>No extra text, explanations, or markdown.</ban>
    </output>

    <example>
        <out>[0.85, 0.1, 0.65]</out>
    </example>
</prompt></textarea>
                    </div>
                  </div>
                </details>
              </section>

              <section class="anyai-form-section" aria-labelledby="keys-heading">
                <details id="keys-section" class="section-toggle">
                  <summary>
                    <h2 id="keys-heading" class="mt-0">APIキー設定</h2>
                    <span class="caret" aria-hidden="true">▸</span>
                  </summary>
                  <form id="keys-form" class="stack">
                    <div class="field"><label for="gemini_api_key">Gemini API Key</label><input type="password" name="gemini_api_key" id="gemini_api_key" placeholder="GEMINI_API_KEY" /></div>
                    <div class="field"><label for="openai_api_key">OpenAI API Key</label><input type="password" name="openai_api_key" id="openai_api_key" placeholder="OPENAI_API_KEY" /></div>
                    <div class="field field-inline">
                      <input type="checkbox" id="persist" name="persist" />
                      <label for="persist">.envに保存（ローカル）</label>
                      <button class="btn btn-outline right" type="submit">保存</button>
                    </div>
                  </form>
                </details>
              </section>
            </div>
          </section>

          <aside class="anyai-app-support">
            <div class="anyai-support-card support-metrics">
              <div class="support-header">
                <h2 class="mt-0">ジョブキュー</h2>
                <button id="btn-queue-start" class="btn btn-primary" type="button">キュー開始</button>
              </div>
              <div id="queue-status" class="muted"></div>
              <div class="actions-row">
                <button class="btn btn-outline" id="btn-queue-add" type="button">キューに追加</button>
              </div>
              <div id="queue-list" class="stack-sm"></div>
            </div>

            <section id="result" class="anyai-support-card" style="display:none;">
              <div class="stack-sm">
                <div>ジョブID: <code id="job-id"></code></div>
                <progress id="prog" value="0" max="100"></progress>
                <div class="row"><span id="stat" class="text-subtle"></span><span class="right" id="eta"></span></div>
                <div id="links" class="actions-row" style="display:none;">
                  <a id="dl-meta" class="btn btn-outline" href="#">run_meta.json</a>
                </div>
                <div class="actions-row" style="justify-content:flex-end;">
                  <button id="btn-cancel-job" class="btn btn-danger" type="button" style="display:none;">強制終了</button>
                </div>
              </div>
            </section>
          </aside>
        </div>
      </main>
    </div>

    <div class="anyai-action-bar" role="region" aria-label="スコアリング操作">
      <button type="button" class="btn btn-outline" id="btn-check-status">再取得</button>
      <button type="button" class="btn btn-primary" id="btn-queue-add-start">実行</button>
    </div>

    <script>
      const loadingOverlay = window.AnyAILoading || {
        run: async (task) => task(),
        show: () => {},
        hide: () => {},
        wrap: (promise) => promise,
      };

      const modeForm = document.getElementById('mode-form');
      const jobForm = document.getElementById('job-form');
      const batchSizeInput = jobForm.querySelector('input[name="batch_size"]');
      const concurrencyInput = document.getElementById('concurrency-input');
      const timeoutInput = document.getElementById('timeout-input');
      const sheetKeywordHelp = document.getElementById('sheet-keyword-help');
      const scoreSheetKeywordHelp = document.getElementById('score-sheet-keyword-help');
      const utteranceLabel = document.getElementById('utterance-label');
      const MODE_DEFAULTS = {
        csv: { batchSize: '10', concurrency: '50', timeout: '60' },
        video: { batchSize: '10', concurrency: '15', timeout: '300' }
      };
      const spreadsheetUrlInput = document.getElementById('spreadsheet_url');
      const sheetKeywordInput = document.getElementById('sheet_keyword');
      const scoreSheetKeywordInput = document.getElementById('score_sheet_keyword');
      const modeRadios = modeForm.querySelectorAll('input[name="mode"]');
      const enableSSR = document.getElementById('enable_ssr');
      const queueStatus = document.getElementById('queue-status');
      const cancelButton = document.getElementById('btn-cancel-job');
      const resultSection = document.getElementById('result');
      const queueAddButton = document.getElementById('btn-queue-add');
      const queueAddStartButton = document.getElementById('btn-queue-add-start');
      const checkStatusButton = document.getElementById('btn-check-status');
      const validationBanner = document.getElementById('validation-banner');
      const validationState = { ok: false, payload: null, key: '', message: '' };
      let currentMode = modeForm.querySelector('input[name="mode"]:checked').value;
      let currentJobId = null;
      let pollTimer = null;
      const nonSSRState = {
        csv: { ...MODE_DEFAULTS.csv },
        video: { ...MODE_DEFAULTS.video }
      };
      nonSSRState.csv = {
        batchSize: batchSizeInput.value || MODE_DEFAULTS.csv.batchSize,
        concurrency: concurrencyInput.value || MODE_DEFAULTS.csv.concurrency,
        timeout: timeoutInput.value || MODE_DEFAULTS.csv.timeout
      };

      function buildValidationKey(){
        return [spreadsheetUrlInput.value.trim(), sheetKeywordInput.value.trim()].join('|');
      }

      function setValidationResult(ok, payload, message){
        validationState.ok = !!ok;
        validationState.payload = payload || null;
        validationState.message = message || '';
        validationState.key = buildValidationKey();
      }

      function isValidationCurrent(){
        return validationState.ok && validationState.key === buildValidationKey();
      }

      function showValidationBanner(state, message){
        if(!validationBanner) return;
        if(!state){
          validationBanner.removeAttribute('data-state');
          validationBanner.textContent = message || '';
          return;
        }
        validationBanner.setAttribute('data-state', state);
        validationBanner.textContent = message || '';
      }

      function updateQueueActionState(){
        const valid = isValidationCurrent();
        if(queueAddButton) queueAddButton.disabled = !valid;
        if(queueAddStartButton) queueAddStartButton.disabled = !valid;
      }

      function markValidationDirty(showMessage = true){
        const wasValid = validationState.ok;
        validationState.ok = false;
        validationState.payload = null;
        validationState.key = '';
        if(showMessage && wasValid){
          showValidationBanner('info', '設定が変更されました。右下の「再取得」で検証してください。');
        } else if(!validationBanner?.hasAttribute('data-state')){
          showValidationBanner(null, '');
        }
        updateQueueActionState();
      }

      function stopPolling(){
        if (pollTimer) {
          clearTimeout(pollTimer);
          pollTimer = null;
        }
      }

      async function fetchProgress(jobId){
        const res = await fetch(`/jobs/${jobId}`);
        if (!res.ok) throw new Error('progress fetch failed');
        return res.json();
      }

      async function updateProgress(jobId){
        try {
          const data = await fetchProgress(jobId);
          document.getElementById('prog').value = data.total_rows ? Math.floor((data.processed_rows / data.total_rows) * 100) : 0;
          document.getElementById('stat').textContent = data.status;
          document.getElementById('eta').textContent = data.eta_seconds ? `予測残り ${Math.round(data.eta_seconds)} 秒` : '';
          const isRunning = data.status === 'running' || data.status === 'pending';
          cancelButton.style.display = isRunning ? 'inline-flex' : 'none';
          return isRunning;
        } catch (err) {
          console.error(err);
          cancelButton.style.display = 'none';
          return false;
        }
      }

      async function startPolling(jobId){
        stopPolling();
        if (!jobId) {
          document.getElementById('prog').value = 0;
          document.getElementById('stat').textContent = '';
          document.getElementById('eta').textContent = '';
          return;
        }
        const keepRunning = await updateProgress(jobId);
        if (keepRunning) {
          pollTimer = setTimeout(()=>startPolling(jobId), 2000);
        }
      }

      function storeCurrentNonSSRValues(mode) {
        if (!mode || !nonSSRState[mode]) return;
        nonSSRState[mode] = {
          batchSize: batchSizeInput.value || MODE_DEFAULTS[mode].batchSize,
          concurrency: concurrencyInput.value || MODE_DEFAULTS[mode].concurrency,
          timeout: timeoutInput.value || MODE_DEFAULTS[mode].timeout
        };
      }

      function restoreNonSSRValues(mode) {
        if (!mode) return;
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        const stored = nonSSRState[mode] || defaults;
        batchSizeInput.value = stored.batchSize || defaults.batchSize;
        concurrencyInput.value = stored.concurrency || defaults.concurrency;
        timeoutInput.value = stored.timeout || defaults.timeout;
      }

      function applyModeContent(mode) {
        if (mode === 'video') {
          sheetKeywordHelp.textContent = 'Videoモードでは動画リンク列を指定してください。Google Drive共有リンクを想定。';
          if (scoreSheetKeywordHelp) {
            scoreSheetKeywordHelp.textContent = '動画モードで数値化したスコアを書き込むシート名に含まれるキーワード。';
          }
          utteranceLabel.textContent = '動画リンク列番号';
        } else {
          sheetKeywordHelp.textContent = '自然言語の分析結果を書き込むシート名に含まれるキーワード。該当シートが1つのみである必要があります。';
          if (scoreSheetKeywordHelp) {
            scoreSheetKeywordHelp.textContent = '分析テキストと同じ位置にスコアを書き込むシート名に含まれるキーワード。';
          }
          utteranceLabel.textContent = '発話列番号';
        }
      }

      function updateSSREnabled() {
        const enabled = enableSSR.checked;
        document.querySelectorAll('[data-ssr-mode]').forEach((el) => {
          const mode = el.getAttribute('data-ssr-mode');
          const show = mode === 'on' ? enabled : !enabled;
          el.style.display = show ? '' : 'none';
        });
      }

      function applyMode(mode) {
        applyModeContent(mode);
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        if (enableSSR.checked) {
          batchSizeInput.value = '1';
          concurrencyInput.value = '1';
          timeoutInput.value = defaults.timeout || MODE_DEFAULTS.csv.timeout;
          batchSizeInput.disabled = true;
          concurrencyInput.disabled = true;
        } else {
          restoreNonSSRValues(mode);
          batchSizeInput.disabled = false;
          concurrencyInput.disabled = false;
          const stored = nonSSRState[mode] || defaults;
          timeoutInput.value = stored.timeout || defaults.timeout;
        }
        updateSSREnabled();
      }

      function handleSSRChange() {
        if (enableSSR.checked) {
          storeCurrentNonSSRValues(currentMode);
        }
        applyMode(currentMode);
      }

      function appendPromptFields(fd) {
        fd.set('enable_ssr', enableSSR.checked ? 'true' : 'false');
        fd.set('system_prompt_ssr', form.system_prompt_ssr.value || '');
        fd.set('system_prompt_numeric', form.system_prompt_numeric.value || '');
        const activePrompt = enableSSR.checked ? form.system_prompt_ssr.value : form.system_prompt_numeric.value;
        fd.set('system_prompt', activePrompt || '');
      }

      enableSSR.addEventListener('change', () => {
        handleSSRChange();
      });

      modeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (!radio.checked) return;
          if (!enableSSR.checked) {
            storeCurrentNonSSRValues(currentMode);
          }
          currentMode = radio.value;
          applyMode(currentMode);
        });
      });

      batchSizeInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].batchSize = batchSizeInput.value;
      });
      concurrencyInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].concurrency = concurrencyInput.value;
      });
      timeoutInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].timeout = timeoutInput.value;
      });

      handleSSRChange();

      // Settings status
      async function refreshKeysStatus(){
        try{
          const el = document.getElementById('keys-status');
          if(!el) return;
          const r = await fetch('/settings');
          if(!r.ok) return;
          const j = await r.json();
          const s = j.keys || {};
          el.textContent = `Gemini=${s.gemini?'セット済み':'未設定'} / OpenAI=${s.openai?'セット済み':'未設定'}`;
        }catch{}
      }

      const kf = document.getElementById('keys-form');
      kf.addEventListener('submit', async (e)=>{
        e.preventDefault();
        const fd = new FormData(kf);
        fd.set('persist', document.getElementById('persist').checked ? 'true' : 'false');
        const r = await fetch('/settings', { method:'POST', body: fd });
        if(!r.ok){ alert('APIキー保存に失敗しました'); return; }
        await refreshKeysStatus();
        alert('APIキーを反映しました');
      });

      const form = jobForm;

      [spreadsheetUrlInput, sheetKeywordInput].forEach((input) => {
        if (!input) return;
        input.addEventListener('input', () => markValidationDirty());
      });

      if (checkStatusButton) {
        checkStatusButton.addEventListener('click', async (e) => {
          e.preventDefault();
          const url = spreadsheetUrlInput.value.trim();
          const sheetKeyword = sheetKeywordInput.value.trim() || 'Link';
          if (!url) {
            const message = 'スプレッドシートURLを入力してください。';
            showValidationBanner('error', message);
            setValidationResult(false, null, message);
            updateQueueActionState();
            return;
          }
          showValidationBanner('info', 'スプレッドシートを検証中です...');
          checkStatusButton.disabled = true;
          try {
            const res = await fetch('/jobs/check', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ spreadsheet_url: url, sheet_keyword: sheetKeyword }),
            });
            let data = null;
            try {
              data = await res.json();
            } catch (err) {
              data = null;
            }
            if (!res.ok || !data || !data.ok) {
              const message = (data && data.message) || 'スプレッドシートの検証に失敗しました。';
              showValidationBanner('error', message);
              setValidationResult(false, data, message);
            } else {
              const message = data.message || 'スプレッドシートを確認しました。';
              showValidationBanner('success', message);
              setValidationResult(true, data, message);
            }
          } catch (err) {
            const message = `検証に失敗しました: ${err instanceof Error ? err.message : err}`;
            showValidationBanner('error', message);
            setValidationResult(false, null, message);
          } finally {
            checkStatusButton.disabled = false;
            updateQueueActionState();
          }
        });
      }

      updateQueueActionState();

      if (queueAddButton) {
        queueAddButton.addEventListener('click', async (e) => {
          e.preventDefault();
          if(!isValidationCurrent()){
            showValidationBanner('error', 'スプレッドシート設定の検証を完了してください（右下の「再取得」）。');
            return;
          }
          const fd = new FormData(form);
          fd.set('auto_slowdown', document.getElementById('auto_slowdown').checked ? 'true' : 'false');
          const selectedMode = modeForm.querySelector('input[name="mode"]:checked').value;
          fd.append('mode', selectedMode);
          appendPromptFields(fd);
          fd.append('action', 'queue');
          const res = await fetch('/jobs', { method: 'POST', body: fd });
          if (!res.ok) { alert('キュー追加に失敗'); return; }
          await refreshQueue();
          alert('キューに追加しました');
        });
      }

      if (queueAddStartButton) {
        queueAddStartButton.addEventListener('click', async (e) => {
          e.preventDefault();
          if(!isValidationCurrent()){
            showValidationBanner('error', 'スプレッドシート設定の検証を完了してください（右下の「再取得」）。');
            return;
          }
          await loadingOverlay.run(async () => {
            const fd = new FormData(form);
            fd.set('auto_slowdown', document.getElementById('auto_slowdown').checked ? 'true' : 'false');
            const selectedMode = modeForm.querySelector('input[name="mode"]:checked').value;
            fd.set('mode', selectedMode);
            appendPromptFields(fd);
            fd.set('action', 'start');
            const res = await fetch('/jobs', { method: 'POST', body: fd });
            if (!res.ok) { alert('開始に失敗'); return; }
            const data = await res.json();
            currentJobId = data.job_id;
            resultSection.style.display = 'block';
            document.getElementById('job-id').textContent = currentJobId;
            startPolling(currentJobId);
            await refreshQueue();
          });
        });
      }

      document.getElementById('btn-queue-start').addEventListener('click', async ()=>{
        await fetch('/queue/start', { method:'POST' });
        refreshQueue();
      });

      cancelButton.addEventListener('click', async ()=>{
        if(!currentJobId) return;
        cancelButton.disabled = true;
        try {
          const res = await fetch(`/jobs/${currentJobId}/cancel`, { method: 'POST' });
          if (!res.ok) { alert('キャンセルに失敗しました'); }
          await refreshQueue();
          await updateProgress(currentJobId);
        } finally {
          cancelButton.disabled = false;
        }
      });

      async function refreshQueue(){
        try{
          const r = await fetch('/queue');
          if(!r.ok) return;
          const j = await r.json();
          const list = document.getElementById('queue-list');
          list.innerHTML = '';
          const items = j.items || [];
          const runningId = j.current;
          queueStatus.textContent = j.running ? `稼働中: ${runningId || ''}` : '待機中';
          if (runningId) {
            currentJobId = runningId;
            resultSection.style.display = 'block';
            document.getElementById('job-id').textContent = runningId;
            cancelButton.style.display = 'inline-flex';
            startPolling(runningId);
          } else {
            cancelButton.style.display = 'none';
            currentJobId = null;
            stopPolling();
          }
          items.forEach((it, idx)=>{
            const row = document.createElement('div');
            row.className = 'row';
            row.style.alignItems = 'center';
            row.innerHTML = `<code>${it.job_id}</code> <span class="muted">[${it.mode}]</span> <span>${it.sheet_name||''}</span> <span class="muted">status: ${it.status}</span>`;
            const right = document.createElement('div');
            right.className = 'right';

            const up = document.createElement('button'); up.className='btn btn-ghost'; up.textContent='↑';
            up.onclick = async ()=>{ const pos = Math.max(0, idx-1); const fd=new FormData(); fd.set('position', pos); await fetch(`/queue/${it.job_id}/move`, {method:'POST', body:fd}); refreshQueue(); };
            const down = document.createElement('button'); down.className='btn btn-ghost'; down.textContent='↓';
            down.onclick = async ()=>{ const pos = idx+1; const fd=new FormData(); fd.set('position', pos); await fetch(`/queue/${it.job_id}/move`, {method:'POST', body:fd}); refreshQueue(); };
            const edit = document.createElement('button'); edit.className='btn btn-outline'; edit.textContent='編集';
            edit.onclick = async ()=>{
              try{
                const r = await fetch(`/jobs/${it.job_id}/config`);
                if(!r.ok){ alert('設定取得に失敗'); return; }
                const txt = await r.text();
                const cfg = JSON.parse(txt);
                // Populate form with cfg
                form.spreadsheet_url.value = cfg.spreadsheet_url;
                form.sheet_keyword.value = cfg.sheet_keyword || 'Link';
                form.score_sheet_keyword.value = cfg.score_sheet_keyword || 'Embedding';
                form.utterance_col.value = cfg.utterance_col;
                form.category_start_col.value = cfg.category_start_col;
                form.name_row.value = cfg.name_row;
                form.def_row.value = cfg.def_row;
                form.detail_row.value = cfg.detail_row;
                form.start_row.value = cfg.start_row;
                form.batch_size.value = cfg.batch_size;
                form.max_category_cols.value = cfg.max_category_cols;
                form.concurrency.value = cfg.concurrency;
                form.max_retries.value = cfg.max_retries;
                document.getElementById('auto_slowdown').checked = !!cfg.auto_slowdown;
                form.timeout_sec.value = cfg.timeout_sec;
                document.querySelector(`#mode-form input[name="mode"][value="${cfg.mode}"]`).checked = true;
                enableSSR.checked = cfg.enable_ssr !== false;
                form.system_prompt_ssr.value = cfg.ssr_system_prompt || '';
                form.system_prompt_numeric.value = cfg.numeric_system_prompt || '';
                updateSSREnabled();
                form.dataset.editing = it.job_id;
                alert('フォームに読み込みました。下の「編集を保存」で反映できます。');
                validationState.ok = false;
                validationState.payload = null;
                showValidationBanner('info', '読み込んだ設定です。右下の「再取得」で検証してください。');
                updateQueueActionState();
              }catch{}
            };
            const save = document.createElement('button'); save.className='btn btn-primary'; save.textContent='編集を保存';
            save.onclick = async ()=>{
              const ej = form.dataset.editing;
              if(!ej){ alert('編集対象が読み込まれていません'); return; }
              const fd = new FormData(form);
              fd.set('auto_slowdown', document.getElementById('auto_slowdown').checked ? 'true' : 'false');
              const selectedMode = modeForm.querySelector('input[name="mode"]:checked').value;
              fd.set('mode', selectedMode);
              appendPromptFields(fd);
              const r = await fetch(`/queue/${ej}/edit`, { method:'POST', body: fd });
              if(!r.ok){ alert('保存に失敗'); return; }
              alert('保存しました'); form.dataset.editing='';
              refreshQueue();
            };
            const del = document.createElement('button'); del.className='btn btn-danger'; del.textContent='削除';
            del.onclick = async ()=>{ await fetch(`/queue/${it.job_id}`, { method:'DELETE' }); refreshQueue(); };

            right.appendChild(up); right.appendChild(down); right.appendChild(edit); right.appendChild(save); right.appendChild(del);
            row.appendChild(right);
            list.appendChild(row);
          });
        }catch{}
      }

      // 初期ロード
      refreshQueue();
      setInterval(refreshQueue, 2000);

      // ログUI廃止
    </script>
  </body>
  </html>

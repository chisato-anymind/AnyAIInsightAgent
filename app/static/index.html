<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="color-scheme" content="light dark" />
    <title>AnyAI Scoring — スコアリングAIエージェント</title>
    <link rel="icon" href="/static/anyai/assets/AnyAI_icon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/anyai/core/anyai.tokens.css" />
    <link rel="stylesheet" href="/static/anyai/core/anyai.components.css" />
    <link rel="stylesheet" href="/static/anyai/core/anyai.utilities.css" />
    <link rel="stylesheet" href="/static/anyai/tool-layout.css" />
    <script src="/static/anyai/loading-overlay.js"></script>
    <script defer src="/static/anyai/vendor/lucide.js"></script>
    <script defer src="/static/anyai/sidebar.js"></script>
    
    <style>
      .mode-options { display: flex; flex-wrap: wrap; gap: var(--anyai-space-3); align-items: center; }
      .mode-options label { display: inline-flex; align-items: center; gap: var(--anyai-space-2); font-weight: 600; }
      .mode-options .spacer { flex: 1 1 auto; }

      .stack-sm { display: flex; flex-direction: column; gap: var(--anyai-space-3); }
      .muted { color: var(--anyai-text-subtle); font-size: var(--anyai-fs-2); }

      input[type="number"],
      input[type="text"],
      input[type="password"],
      input[type="file"],
      textarea {
        width: 100%;
        padding: 10px 12px;
        border-radius: var(--anyai-radius-2);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 30%);
        background: var(--anyai-panel);
        font: inherit;
      }

      textarea { min-height: 160px; resize: vertical; }

      progress {
        width: 100%;
        height: 12px;
        border-radius: var(--anyai-radius-2);
        overflow: hidden;
      }

      .validation-banner {
        display: none;
        padding: var(--anyai-space-3) var(--anyai-space-4);
        border-radius: var(--anyai-radius-2);
        font-size: var(--anyai-fs-2);
        font-weight: 600;
      }

      .validation-banner[data-state] { display: block; }
      .validation-banner[data-state="error"] {
        background: color-mix(in srgb, var(--anyai-danger), transparent 80%);
        color: var(--anyai-danger);
      }
      .validation-banner[data-state="success"] {
        background: color-mix(in srgb, var(--anyai-success), transparent 82%);
        color: var(--anyai-success);
      }
      .validation-banner[data-state="info"] {
        background: color-mix(in srgb, var(--anyai-primary), transparent 88%);
        color: var(--anyai-primary-700);
      }

      .actions-row { display: flex; gap: var(--anyai-space-3); flex-wrap: wrap; align-items: center; }
      .band-title { margin: 0; font-size: var(--anyai-fs-3); font-weight: 600; }
      .callout {
        border-radius: var(--anyai-radius-2);
        padding: var(--anyai-space-3) var(--anyai-space-4);
        background: color-mix(in srgb, var(--anyai-primary), transparent 88%);
        font-size: var(--anyai-fs-2);
      }

      .status-badge {
        display: inline-flex;
        align-items: center;
        padding: 0.125rem 0.5rem;
        border-radius: 999px;
        font-size: var(--anyai-fs-2);
        font-weight: 600;
        border: 1px solid transparent;
      }
      .status-badge[data-state="success"] {
        background: color-mix(in srgb, var(--anyai-success), transparent 82%);
        color: var(--anyai-success);
        border-color: color-mix(in srgb, var(--anyai-success), transparent 65%);
      }
      .status-badge[data-state="error"] {
        background: color-mix(in srgb, var(--anyai-danger), transparent 82%);
        color: var(--anyai-danger);
        border-color: color-mix(in srgb, var(--anyai-danger), transparent 65%);
      }
      .status-badge[data-state="info"] {
        background: color-mix(in srgb, var(--anyai-primary), transparent 88%);
        color: var(--anyai-primary-700);
        border-color: color-mix(in srgb, var(--anyai-primary), transparent 70%);
      }

      .validation-meta {
        margin-top: var(--anyai-space-3);
        display: flex;
        flex-direction: column;
        gap: var(--anyai-space-2);
      }
      .validation-meta-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: var(--anyai-space-2);
        font-size: var(--anyai-fs-2);
      }
      .validation-meta-label {
        color: var(--anyai-text-subtle);
        font-weight: 600;
      }

      .log-viewer {
        max-height: 240px;
        width: 100%;
        padding: var(--anyai-space-3) var(--anyai-space-4);
        background: color-mix(in srgb, var(--anyai-panel), transparent 10%);
        border-radius: var(--anyai-radius-2);
        border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 10%);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.85rem;
        color: var(--anyai-text);
        white-space: pre-wrap;
        word-break: break-word;
        overflow: auto;
      }

      .btn[aria-busy="true"] {
        position: relative;
        pointer-events: none;
      }

      .btn[aria-busy="true"]::after {
        content: "";
        position: absolute;
        inset: calc(50% - 0.75em) auto auto calc(50% - 0.75em);
        width: 1.5em;
        height: 1.5em;
        border-radius: 999px;
        border: 2px solid color-mix(in srgb, var(--anyai-text), transparent 40%);
        border-top-color: var(--anyai-primary);
        animation: anyai-btn-spin 0.9s linear infinite;
      }

      @keyframes anyai-btn-spin {
        from { transform: rotate(0turn); }
        to { transform: rotate(1turn); }
      }

      .support-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--anyai-space-3);
      }

      .support-header h2 { margin: 0; font-size: var(--anyai-fs-4); }

      details.section-toggle > summary {
        display: flex;
        align-items: center;
        gap: var(--anyai-space-3);
        cursor: pointer;
        list-style: none;
      }

      details.section-toggle > summary::-webkit-details-marker { display: none; }
      .caret { font-size: 18px; opacity: 0.8; margin-left: auto; transition: transform 0.2s ease; }
      details[open] .caret { transform: rotate(90deg); }

      pre { max-width: 100%; white-space: pre-wrap; word-break: break-word; }
    </style>
  </head>
  <body>
    <div class="anyai-layout">
      <aside class="anyai-sidebar" data-active-tool="scoring"></aside>
      <main class="anyai-content">
        <div class="anyai-app">
          <section class="anyai-app-primary" aria-labelledby="scoring-heading">
            <h1 id="scoring-heading" class="mt-0">スコアリング実行</h1>
            <p class="field-hint">スプレッドシートから概念ごとのスコアを一括で生成します。</p>

            <div class="anyai-form" aria-labelledby="scoring-config-heading">
              <section class="anyai-form-section" aria-labelledby="mode-heading">
                <header>
                  <h2 id="mode-heading" class="mt-0">モード設定</h2>
                  <p class="field-hint">処理対象のメディアとSSRモードを切り替えます。</p>
                </header>
                <form id="mode-form">
                  <fieldset class="field">
                    <legend>実行モード</legend>
                    <div class="mode-options">
                      <label><input type="radio" name="mode" value="csv" checked /> Textモード</label>
                      <label><input type="radio" name="mode" value="video" /> Videoモード</label>
                      <span class="spacer"></span>
                    </div>
                  </fieldset>
                  <div class="field field-inline">
                    <input type="checkbox" id="enable_ssr" name="enable_ssr" checked />
                    <label for="enable_ssr">SSRモードを有効化（推奨）</label>
                  </div>
                </form>
              </section>

              <section class="anyai-form-section" aria-labelledby="input-heading">
                <header>
                  <h2 id="input-heading" class="mt-0">入力設定</h2>
                  <p class="field-hint">スコアリング対象となるスプレッドシートと列情報を設定します。</p>
                </header>
                <form id="job-form">
                  <div class="anyai-form-fields">
                    <div class="field">
                      <label for="spreadsheet_url">スプレッドシートURL</label>
                      <p class="field-hint">共有リンクをそのまま貼り付けます。</p>
                      <input type="text" id="spreadsheet_url" name="spreadsheet_url" placeholder="https://docs.google.com/spreadsheets/d/..." required />
                    </div>
                    <div class="field">
                      <label for="sheet_keyword">分析テキスト シートキーワード</label>
                      <p class="field-hint">分析テキストを書き込むシート名のキーワード。</p>
                      <input type="text" id="sheet_keyword" name="sheet_keyword" value="Link" placeholder="Link" />
                      <details class="field-info">
                        <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                        <div class="info-panel" id="sheet-keyword-help">自然言語の分析結果を書き込むシート名に含まれるキーワード。該当シートが1つのみである必要があります。</div>
                      </details>
                    </div>
                    <div class="field">
                      <label for="score_sheet_keyword">スコア出力 シートキーワード</label>
                      <p class="field-hint">スコアを書き込むシート名に含まれるキーワード。</p>
                      <input type="text" id="score_sheet_keyword" name="score_sheet_keyword" value="Embedding" placeholder="Embedding" />
                      <details class="field-info">
                        <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                        <div class="info-panel" id="score-sheet-keyword-help">Linkシートで得た分析テキストを数値化した結果を保存するシート名に含まれるキーワード。</div>
                      </details>
                    </div>
                  </div>
                  <div id="validation-banner" class="validation-banner" role="status" aria-live="polite"></div>

                  <div class="anyai-form-group" aria-labelledby="mapping-heading">
                    <h3 id="mapping-heading" class="band-title">マッピング設定（1始まり）</h3>
                    <div class="anyai-form-fields is-two-column">
                      <div class="field"><label id="utterance-label" for="utterance_col">発話列番号</label><input type="number" name="utterance_col" id="utterance_col" value="3" min="1" /></div>
                      <div class="field"><label for="category_start_col">カテゴリ開始列番号</label><input type="number" name="category_start_col" id="category_start_col" value="4" min="1" /></div>
                      <div class="field"><label for="name_row">カテゴリ名 行番号</label><input type="number" name="name_row" id="name_row" value="2" min="1" /></div>
                      <div class="field"><label for="def_row">定義 行番号</label><input type="number" name="def_row" id="def_row" value="3" min="1" /></div>
                      <div class="field"><label for="detail_row">Detail 行番号</label><input type="number" name="detail_row" id="detail_row" value="4" min="1" /></div>
                      <div class="field"><label for="start_row">処理開始行番号</label><input type="number" name="start_row" id="start_row" value="5" min="1" /></div>
                    </div>
                  </div>

                  <div class="anyai-form-group" aria-labelledby="execution-heading">
                    <h3 id="execution-heading" class="band-title">実行設定</h3>
                    <div class="anyai-form-fields is-two-column">
                      <div class="field"><label for="batch_size">カテゴリ同梱数 N</label><input type="number" name="batch_size" id="batch_size" value="10" min="1" max="50" />
                        <p class="field-hint">Videoモードでは 1 に固定されます。</p>
                      </div>
                      <div class="field"><label for="max_category_cols">最大カテゴリ列数</label><input type="number" name="max_category_cols" id="max_category_cols" value="200" min="1" max="10000" />
                        <p class="field-hint">Videoモードでは最初の列のみ処理します。</p>
                      </div>
                      <div class="field"><label for="concurrency-input">同時実行数</label><input type="number" name="concurrency" value="50" min="1" max="200" id="concurrency-input" /></div>
                      <div class="field"><label for="max_retries">最大リトライ回数</label><input type="number" name="max_retries" id="max_retries" value="10" min="0" max="50" /></div>
                      <div class="field"><label for="timeout-input">タイムアウト秒</label><input type="number" name="timeout_sec" value="60" min="10" max="600" id="timeout-input" /></div>
                      <div class="field field-inline"><input type="checkbox" name="auto_slowdown" id="auto_slowdown" checked /><label for="auto_slowdown">429自動降速</label></div>
                    </div>
                  </div>

                  <div class="anyai-form-group" aria-labelledby="ssr-heading">
                    <h3 id="ssr-heading" class="band-title">SSR設定</h3>
                    <div id="ssr-settings-body" class="stack">
                      <div class="callout" data-ssr-mode="on">
                        <strong>SSRオン:</strong> カテゴリごとに短い英語の根拠文を生成し、内部でベクトル化してスコアします。
                      </div>
                      <div class="callout" data-ssr-mode="off" style="display:none;">
                        <strong>SSRオフ:</strong> LLMに直接 0.0〜1.0 の数値配列を出力させます（根拠文は省略されます）。
                      </div>
                    </div>
                  </div>
                </form>
              </section>

              <section class="anyai-form-section" aria-labelledby="prompt-heading">
                <details id="sys-section" class="section-toggle">
                  <summary>
                    <h2 id="prompt-heading" class="mt-0">System Prompts</h2>
                    <span class="caret" aria-hidden="true">▸</span>
                  </summary>
                  <div class="stack">
                    <div>
                      <label for="system_prompt_ssr" class="muted">SSRオン時（定性根拠を英語で生成）</label>
                      <textarea name="system_prompt_ssr" id="system_prompt_ssr" rows="12"><prompt>
    <role id="Semantic Inference Engine & Latent Intent Decoder">
        <spec>Noisy text (SNS, UGC, transcripts) analysis. Infer user's true goals, emotions, and unstated assumptions from fragmented data.</spec>
        <ban>Surface-level keyword matching is strictly forbidden.</ban>
    </role>

    <mission>For a given utterance and N concepts, perform Semantic Similarity Rating (SSR) as described in AnyAI Scoring research (2025-10-14). First verbalize how similar each concept definition is to the latent intent of the utterance. Then provide succinct natural-language rationales that can be embedded for quantitative scoring.</mission>

    <process>
        <step id="1" name="Normalize & Enrich">
            <task>Normalize slang, typos, jargon.</task>
            <task>Interpret non-verbal cues (emojis, punctuation, irony markers) for emotional tone.</task>
        </step>
        <step id="2" name="Contextualize (Hypothesize)">
            <context type="temporal">When? (e.g., weekday morning -> commute?)</context>
            <context type="spatial">Where? (e.g., office -> work?)</context>
            <context type="social">To whom? (e.g., friend, public?)</context>
            <context type="causal">Why? (e.g., "I'm hungry" -> next is food talk?)</context>
            <context type="telic">Goal? (e.g., info-gathering, empathy, decision-making?)</context>
        </step>
        <step id="3" name="Extract Latent Intent">
            <desc>Identify the "real question" or "unspoken need" behind the literal words.</desc>
            <ex>"Any good cafes around here?" -> might mean "Need a quiet place with Wi-Fi to work."</ex>
        </step>
        <step id="4" name="Describe Similarity">
            <desc>For each concept, articulate how closely the latent intent aligns with the concept definition and detail, referencing SSR anchors (Core/Strong/Reasonable/Weak/None).</desc>
        </step>
    </process>

    <output>
        <primary>Return a JSON object with the single key "analyses" whose value is an array of length N. Each element must be a short paragraph (1-2 sentences) written in clear English that begins with one of [Core|Strong|Reasonable|Weak|None] and explains the similarity between the utterance and the concept's definition/detail.</primary>
        <ban>Do not output numeric ratings or markdown tables. No additional keys beyond "analyses".</ban>
    </output>

    <example>
        <out>{"analyses": ["Strong: Mentions planning a cafe visit matching the concept...", "Weak: Only tangential references..."]}</out>
    </example>
</prompt></textarea>
                    </div>
                    <div>
                      <label for="system_prompt_numeric" class="muted">SSRオフ時（直接スコアを算出）</label>
                      <textarea name="system_prompt_numeric" id="system_prompt_numeric" rows="12"><prompt>
    <role id="Semantic Inference Engine & Latent Intent Decoder">
        <spec>Noisy text (SNS, UGC, transcripts) analysis. Infer user's true goals, emotions, and unstated assumptions from fragmented data.</spec>
        <ban>Surface-level keyword matching is strictly forbidden.</ban>
    </role>

    <mission>For a given utterance and N concepts, calculate a relevance score 'r' (float 0.0-1.0, no rounding) based on the utterance's core intent. Execute via the internal process below.</mission>

    <process>
        <step id="1" name="Normalize & Enrich">
            <task>Normalize slang, typos, jargon.</task>
            <task>Interpret non-verbal cues (emojis, punctuation, irony markers) for emotional tone.</task>
        </step>
        <step id="2" name="Contextualize (Hypothesize)">
            <context type="temporal">When? (e.g., weekday morning -> commute?)</context>
            <context type="spatial">Where? (e.g., office -> work?)</context>
            <context type="social">To whom? (e.g., friend, public?)</context>
            <context type="causal">Why? (e.g., "I'm hungry" -> next is food talk?)</context>
            <context type="telic">Goal? (e.g., info-gathering, empathy, decision-making?)</context>
        </step>
        <step id="3" name="Extract Latent Intent">
            <desc>Identify the "real question" or "unspoken need" behind the literal words.</desc>
            <ex>"Any good cafes around here?" -> might mean "Need a quiet place with Wi-Fi to work."</ex>
        </step>
        <step id="4" name="Map & Score">
            <desc>Semantically map the latent intent to each concept's definition. Score relevance 'r' based on the criteria below.</desc>
        </step>
    </process>

    <criteria type="relevance_score_r">
        <score r="0.9-1.0" name="Core">Intent and concept are identical. The utterance exists to express the concept.</score>
        <score r="0.7-0.89" name="Strong">Concept is the primary subject, strongly inferred from context and intent.</score>
        <score r="0.4-0.69" name="Reasonable">Concept is a logical extension or component of the intent.</score>
        <score r="0.1-0.39" name="Weak">Faintly associated by situation/words, but not the main focus.</score>
        <score r="0.0" name="None">No logical connection can be inferred.</score>

    <rules>
        <rule id="lang">Auto-detect language, internally translate to a standard model (e.g., English) for processing.</rule>
        <rule id="silent">Internal thought processes must NOT be included in the output.</rule>
    </rules>

    <output>
        <primary>Return an N-length array of float numbers (0.0–1.0), ordered by the given concepts. No rounding.</primary>
        <compat>If the platform enforces a JSON object wrapper, return only: {"scores": [..the same array..]} with no extra keys or text.</compat>
        <ban>No extra text, explanations, or markdown.</ban>
    </output>

    <example>
        <out>[0.85, 0.1, 0.65]</out>
    </example>
</prompt></textarea>
                    </div>
                  </div>
                </details>
              </section>

              <section class="anyai-form-section" aria-labelledby="keys-heading">
                <details id="keys-section" class="section-toggle">
                  <summary>
                    <h2 id="keys-heading" class="mt-0">APIキー設定</h2>
                    <span class="caret" aria-hidden="true">▸</span>
                  </summary>
                  <form id="keys-form" class="stack">
                    <div class="field"><label for="gemini_api_key">Gemini API Key</label><input type="password" name="gemini_api_key" id="gemini_api_key" placeholder="GEMINI_API_KEY" /></div>
                    <div class="field"><label for="openai_api_key">OpenAI API Key</label><input type="password" name="openai_api_key" id="openai_api_key" placeholder="OPENAI_API_KEY" /></div>
                    <div class="field field-inline">
                      <input type="checkbox" id="persist" name="persist" />
                      <label for="persist">.envに保存（ローカル）</label>
                      <button class="btn btn-outline right" type="submit">保存</button>
                    </div>
                  </form>
                </details>
              </section>
            </div>
          </section>

          <aside class="anyai-app-support">
            <div class="anyai-support-card support-metrics">
              <div class="support-header">
                <h2 class="mt-0">ジョブキュー</h2>
                <button id="btn-queue-start" class="btn btn-primary" type="button">キュー開始</button>
              </div>
              <div id="queue-status" class="muted"></div>
              <div class="actions-row">
                <button class="btn btn-outline" id="btn-queue-add" type="button">キューに追加</button>
              </div>
              <div id="queue-list" class="stack-sm"></div>
            </div>

            <div id="validation-status-card" class="anyai-support-card" style="display:none;">
              <div class="support-header">
                <h2 class="mt-0">検証状況</h2>
                <span id="validation-status-badge" class="status-badge" data-state="info">情報</span>
              </div>
              <p id="validation-status-message" class="muted" role="status" aria-live="polite"></p>
              <div id="validation-status-meta" class="validation-meta"></div>
            </div>

            <div id="job-log-card" class="anyai-support-card">
              <div class="support-header">
                <h2 class="mt-0">実行ログ</h2>
                <button type="button" class="btn btn-outline" id="btn-log-refresh">更新</button>
              </div>
              <pre id="job-log-content" class="log-viewer" tabindex="0">ジョブを開始するとログが表示されます。</pre>
            </div>

            <section id="result" class="anyai-support-card" style="display:none;">
              <div class="stack-sm">
                <div>ジョブID: <code id="job-id"></code></div>
                <progress id="prog" value="0" max="100"></progress>
                <div class="row"><span id="stat" class="text-subtle"></span><span class="right" id="eta"></span></div>
                <div id="links" class="actions-row" style="display:none;">
                  <a id="dl-meta" class="btn btn-outline" href="#">run_meta.json</a>
                </div>
                <div class="actions-row" style="justify-content:flex-end;">
                  <button id="btn-cancel-job" class="btn btn-danger" type="button" style="display:none;">強制終了</button>
                </div>
              </div>
            </section>
          </aside>
        </div>
      </main>
    </div>

    <div class="anyai-action-bar" role="region" aria-label="スコアリング操作">
      <button type="button" class="btn btn-outline" id="btn-check-status">CheckSheetInfo</button>
      <button type="button" class="btn btn-primary" id="btn-queue-add-start" style="display:none;">Run</button>
    </div>

    <script>
      const loadingOverlay = window.AnyAILoading || {
        run: async (task) => task(),
        show: () => {},
        hide: () => {},
        wrap: (promise) => promise,
      };

      const modeForm = document.getElementById('mode-form');
      const jobForm = document.getElementById('job-form');
      const batchSizeInput = jobForm.querySelector('input[name="batch_size"]');
      const maxCategoryInput = document.getElementById('max_category_cols');
      const concurrencyInput = document.getElementById('concurrency-input');
      const timeoutInput = document.getElementById('timeout-input');
      const sheetKeywordHelp = document.getElementById('sheet-keyword-help');
      const scoreSheetKeywordHelp = document.getElementById('score-sheet-keyword-help');
      const utteranceLabel = document.getElementById('utterance-label');
      const MODE_DEFAULTS = {
        csv: { batchSize: '10', maxCategoryCols: '200', concurrency: '50', timeout: '60' },
        video: { batchSize: '1', maxCategoryCols: '1', concurrency: '15', timeout: '300' }
      };
      const spreadsheetUrlInput = document.getElementById('spreadsheet_url');
      const sheetKeywordInput = document.getElementById('sheet_keyword');
      const scoreSheetKeywordInput = document.getElementById('score_sheet_keyword');
      const modeRadios = modeForm.querySelectorAll('input[name="mode"]');
      const enableSSR = document.getElementById('enable_ssr');
      const queueStatus = document.getElementById('queue-status');
      const cancelButton = document.getElementById('btn-cancel-job');
      const resultSection = document.getElementById('result');
      const queueAddButton = document.getElementById('btn-queue-add');
      const queueAddStartButton = document.getElementById('btn-queue-add-start');
      const checkStatusButton = document.getElementById('btn-check-status');
      const validationBanner = document.getElementById('validation-banner');
      const validationStatusCard = document.getElementById('validation-status-card');
      const validationStatusBadge = document.getElementById('validation-status-badge');
      const validationStatusMessage = document.getElementById('validation-status-message');
      const validationStatusMeta = document.getElementById('validation-status-meta');
      const autoSlowdownToggle = document.getElementById('auto_slowdown');
      const systemPromptSSRInput = document.getElementById('system_prompt_ssr');
      const systemPromptNumericInput = document.getElementById('system_prompt_numeric');
      const logCard = document.getElementById('job-log-card');
      const logContent = document.getElementById('job-log-content');
      const logRefreshButton = document.getElementById('btn-log-refresh');
      const defaultLogMessage = 'ジョブを開始するとログが表示されます。';
      const validation = (() => {
        const state = { ok: false, payload: null, cacheKey: '', message: '', status: 'info' };

        function buildKey() {
          const url = spreadsheetUrlInput.value.trim();
          const sheetKeyword = sheetKeywordInput.value.trim();
          const scoreKeyword = scoreSheetKeywordInput ? scoreSheetKeywordInput.value.trim() : '';
          return [url, sheetKeyword, scoreKeyword].join('|');
        }

        function updateCard(status = 'info', message = '', payload = null) {
          if (!validationStatusCard) return;
          const normalizedStatus = status || 'info';
          const hasMeta =
            payload && typeof payload === 'object' && payload !== null && Object.keys(payload).length > 0;
          const hasMessage = Boolean(message);

          if (!hasMessage && !hasMeta && normalizedStatus === 'idle') {
            validationStatusCard.style.display = 'none';
            return;
          }

          validationStatusCard.style.display = '';
          if (validationStatusBadge) {
            const labelMap = { success: '検証済み', error: '要対応', info: '情報', idle: '情報' };
            validationStatusBadge.textContent = labelMap[normalizedStatus] || '情報';
            validationStatusBadge.setAttribute(
              'data-state',
              normalizedStatus === 'idle' ? 'info' : normalizedStatus,
            );
          }

          if (validationStatusMessage) {
            validationStatusMessage.textContent = message || '右下の CheckSheetInfo で検証してください。';
          }

          if (validationStatusMeta) {
            validationStatusMeta.replaceChildren();
            if (hasMeta) {
              const entries = [];
              if (payload.sheet_name) entries.push(['Sheet Name', String(payload.sheet_name)]);
              if (payload.sheet_id !== undefined && payload.sheet_id !== null) {
                entries.push(['Sheet ID', String(payload.sheet_id)]);
              }
              if (payload.spreadsheet_id) {
                entries.push(['Spreadsheet ID', String(payload.spreadsheet_id)]);
              }
              if (
                payload.score_sheet_name &&
                payload.score_sheet_name !== payload.sheet_name
              ) {
                entries.push(['Score Sheet', String(payload.score_sheet_name)]);
              }
              if (
                payload.score_sheet_id !== undefined &&
                payload.score_sheet_id !== null &&
                payload.score_sheet_id !== payload.sheet_id
              ) {
                entries.push(['Score Sheet ID', String(payload.score_sheet_id)]);
              }

              if (entries.length) {
                entries.forEach(([label, value]) => {
                  const row = document.createElement('div');
                  row.className = 'validation-meta-row';
                  const labelEl = document.createElement('span');
                  labelEl.className = 'validation-meta-label';
                  labelEl.textContent = label;
                  const valueEl = document.createElement('code');
                  valueEl.textContent = value;
                  row.appendChild(labelEl);
                  row.appendChild(valueEl);
                  validationStatusMeta.appendChild(row);
                });
                validationStatusMeta.style.display = '';
              } else {
                validationStatusMeta.style.display = 'none';
              }
            } else {
              validationStatusMeta.style.display = 'none';
            }
          }
        }

        function setResult(ok, payload, message, status) {
          state.ok = Boolean(ok);
          state.payload = payload ?? null;
          state.message = message ?? '';
          state.status = status || (state.ok ? 'success' : 'error');
          state.cacheKey = state.ok ? buildKey() : '';
          updateCard(state.status, state.message, state.payload);
        }

        function markDirty(showMessage = true) {
          const wasValid = state.ok;
          state.ok = false;
          state.payload = null;
          state.cacheKey = '';
          state.status = 'info';
          state.message = '';
          const infoMessage = wasValid
            ? '設定が変更されました。右下の CheckSheetInfo を実行してください。'
            : '右下の CheckSheetInfo で検証してください。';
          updateCard('info', infoMessage, null);
          if (showMessage && wasValid) {
            showValidationBanner('info', '設定が変更されました。右下の「CheckSheetInfo」で検証してください。');
          } else if (!validationBanner?.hasAttribute('data-state')) {
            showValidationBanner(null, '');
          }
        }

        function isCurrent() {
          return state.ok && state.cacheKey === buildKey();
        }

        return { state, buildKey, updateCard, setResult, markDirty, isCurrent };
      })();

      function resetLogView() {
        if (!logCard || !logContent) return;
        logContent.textContent = defaultLogMessage;
      }

      async function refreshJobLog(jobId, { manual = false } = {}) {
        if (!logCard || !logContent) return;
        if (!jobId) {
          resetLogView();
          return;
        }
        try {
          const res = await fetch(`/jobs/${jobId}/log?lines=400`);
          if (!res.ok) {
            if (res.status === 404) {
              logContent.textContent = 'ログはまだ生成されていません。';
              return;
            }
            throw new Error(`status ${res.status}`);
          }
          const data = await res.json();
          const logText = data.log || '';
          logContent.textContent = logText || 'ログはまだ記録されていません。';
          logContent.scrollTop = logContent.scrollHeight;
        } catch (err) {
          if (manual) {
            alert('ログの取得に失敗しました。');
          } else {
            console.warn('Failed to load job log', err);
          }
        }
      }
      let currentMode = modeForm.querySelector('input[name="mode"]:checked').value;
      let currentJobId = null;
      let pollTimer = null;

      if (logRefreshButton) {
        logRefreshButton.addEventListener('click', () => {
          if (currentJobId) {
            refreshJobLog(currentJobId, { manual: true });
          } else {
            resetLogView();
          }
        });
      }

      const nonSSRState = {
        csv: { ...MODE_DEFAULTS.csv },
        video: { ...MODE_DEFAULTS.video }
      };
      nonSSRState.csv = {
        batchSize: batchSizeInput.value || MODE_DEFAULTS.csv.batchSize,
        maxCategoryCols: (maxCategoryInput && maxCategoryInput.value) || MODE_DEFAULTS.csv.maxCategoryCols,
        concurrency: concurrencyInput.value || MODE_DEFAULTS.csv.concurrency,
        timeout: timeoutInput.value || MODE_DEFAULTS.csv.timeout
      };

      function setValidationResult(ok, payload, message, status){
        validation.setResult(ok, payload, message, status);
        updateQueueActionState();
      }

      function isValidationCurrent(){
        return validation.isCurrent();
      }

      function showValidationBanner(state, message){
        if(!validationBanner) return;
        if(!state){
          validationBanner.removeAttribute('data-state');
          validationBanner.textContent = message || '';
          return;
        }
        validationBanner.setAttribute('data-state', state);
        validationBanner.textContent = message || '';
      }

      function updateQueueActionState(){
        const valid = isValidationCurrent();
        if(queueAddButton) queueAddButton.disabled = !valid;
        if(queueAddStartButton){
          queueAddStartButton.disabled = !valid;
          queueAddStartButton.style.display = valid ? '' : 'none';
        }
        if(checkStatusButton){
          checkStatusButton.style.display = valid ? 'none' : '';
          if (!valid) {
            checkStatusButton.disabled = false;
          }
        }
      }

      function lockActionButtons(lock) {
        [queueAddButton, checkStatusButton].forEach((btn) => {
          if (!btn) return;
          if (lock) {
            btn.dataset.prevDisabled = btn.disabled ? 'true' : 'false';
            btn.disabled = true;
          } else {
            const wasDisabled = btn.dataset.prevDisabled === 'true';
            delete btn.dataset.prevDisabled;
            btn.disabled = wasDisabled;
          }
        });
        if (!lock) {
          updateQueueActionState();
        }
      }

      function setButtonBusy(button, busyLabel){
        if(!button) return () => {};
        const original = {
          text: button.textContent,
          width: button.offsetWidth,
          disabled: button.disabled,
        };
        button.style.minWidth = `${original.width || button.getBoundingClientRect().width}px`;
        button.setAttribute('aria-busy', 'true');
        button.disabled = true;
        if (busyLabel) {
          button.textContent = busyLabel;
        }
        return () => {
          button.removeAttribute('aria-busy');
          button.style.removeProperty('min-width');
          if (busyLabel) {
            button.textContent = original.text;
          }
          button.disabled = original.disabled;
        };
      }

      async function runWithOverlay(task){
        try {
          loadingOverlay.show();
        } catch (err) {
          console.warn('Failed to show loading overlay', err);
        }
        try {
          return await task();
        } finally {
          try {
            loadingOverlay.hide();
          } catch (err) {
            console.warn('Failed to hide loading overlay', err);
          }
        }
      }

      async function ensureQueueRunning() {
        try {
          const res = await fetch('/queue/start', { method: 'POST' });
          if (!res.ok) {
            console.warn('Queue runner start request failed', res.status);
          }
        } catch (err) {
          console.warn('Unable to trigger queue runner', err);
        }
      }

      function markValidationDirty(showMessage = true){
        validation.markDirty(showMessage);
        updateQueueActionState();
      }

      function stopPolling(){
        if (pollTimer) {
          clearTimeout(pollTimer);
          pollTimer = null;
        }
      }

      async function fetchProgress(jobId){
        const res = await fetch(`/jobs/${jobId}`);
        if (!res.ok) throw new Error('progress fetch failed');
        return res.json();
      }

      async function updateProgress(jobId){
        try {
          const data = await fetchProgress(jobId);
          document.getElementById('prog').value = data.total_rows ? Math.floor((data.processed_rows / data.total_rows) * 100) : 0;
          document.getElementById('stat').textContent = data.status;
          document.getElementById('eta').textContent = data.eta_seconds ? `予測残り ${Math.round(data.eta_seconds)} 秒` : '';
          const isRunning = data.status === 'running' || data.status === 'pending';
          cancelButton.style.display = isRunning ? 'inline-flex' : 'none';
          return isRunning;
        } catch (err) {
          console.error(err);
          cancelButton.style.display = 'none';
          return false;
        }
      }

      async function startPolling(jobId){
        stopPolling();
        if (!jobId) {
          document.getElementById('prog').value = 0;
          document.getElementById('stat').textContent = '';
          document.getElementById('eta').textContent = '';
          resetLogView();
          return;
        }
        const keepRunning = await updateProgress(jobId);
        await refreshJobLog(jobId);
        if (keepRunning) {
          pollTimer = setTimeout(()=>startPolling(jobId), 2000);
        }
      }

      function storeCurrentNonSSRValues(mode) {
        if (!mode || !nonSSRState[mode]) return;
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        nonSSRState[mode] = {
          batchSize: batchSizeInput.value || defaults.batchSize,
          maxCategoryCols: (maxCategoryInput && maxCategoryInput.value) || defaults.maxCategoryCols,
          concurrency: concurrencyInput.value || defaults.concurrency,
          timeout: timeoutInput.value || defaults.timeout
        };
      }

      function restoreNonSSRValues(mode) {
        if (!mode) return;
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        const stored = nonSSRState[mode] || defaults;
        batchSizeInput.value = stored.batchSize || defaults.batchSize;
        if (maxCategoryInput) {
          maxCategoryInput.value = stored.maxCategoryCols || defaults.maxCategoryCols;
        }
        concurrencyInput.value = stored.concurrency || defaults.concurrency;
        timeoutInput.value = stored.timeout || defaults.timeout;
      }

      function applyModeContent(mode) {
        if (mode === 'video') {
          sheetKeywordHelp.textContent = 'Videoモードでは動画リンク列を指定してください。Google Drive共有リンクを想定。';
          if (scoreSheetKeywordHelp) {
            scoreSheetKeywordHelp.textContent = '動画モードで数値化したスコアを書き込むシート名に含まれるキーワード。';
          }
          utteranceLabel.textContent = '動画リンク列番号';
        } else {
          sheetKeywordHelp.textContent = '自然言語の分析結果を書き込むシート名に含まれるキーワード。該当シートが1つのみである必要があります。';
          if (scoreSheetKeywordHelp) {
            scoreSheetKeywordHelp.textContent = '分析テキストと同じ位置にスコアを書き込むシート名に含まれるキーワード。';
          }
          utteranceLabel.textContent = '発話列番号';
        }
      }

      function updateSSREnabled() {
        const enabled = enableSSR.checked;
        document.querySelectorAll('[data-ssr-mode]').forEach((el) => {
          const mode = el.getAttribute('data-ssr-mode');
          const show = mode === 'on' ? enabled : !enabled;
          el.style.display = show ? '' : 'none';
        });
      }

      function applyMode(mode) {
        applyModeContent(mode);
        const defaults = MODE_DEFAULTS[mode] || MODE_DEFAULTS.csv;
        const isVideoMode = mode === 'video';
        const ssrEnabled = enableSSR.checked;

        if (ssrEnabled) {
          batchSizeInput.disabled = false;
          concurrencyInput.disabled = false;
          if (isVideoMode) {
            batchSizeInput.value = defaults.batchSize || MODE_DEFAULTS.video.batchSize;
            if (maxCategoryInput) {
              maxCategoryInput.value = defaults.maxCategoryCols || defaults.batchSize || MODE_DEFAULTS.video.maxCategoryCols;
            }
          } else {
            if (!batchSizeInput.value) {
              batchSizeInput.value = defaults.batchSize || MODE_DEFAULTS.csv.batchSize;
            }
            if (maxCategoryInput && !maxCategoryInput.value) {
              maxCategoryInput.value = defaults.maxCategoryCols || MODE_DEFAULTS.csv.maxCategoryCols;
            }
          }
          if (!concurrencyInput.value) {
            concurrencyInput.value = defaults.concurrency || MODE_DEFAULTS.csv.concurrency;
          }
          timeoutInput.value = defaults.timeout || MODE_DEFAULTS.csv.timeout;
        } else {
          restoreNonSSRValues(mode);
          batchSizeInput.disabled = false;
          concurrencyInput.disabled = false;
        }

        if (isVideoMode) {
          const lockedBatch = defaults.batchSize || MODE_DEFAULTS.video.batchSize || '1';
          batchSizeInput.value = lockedBatch;
          batchSizeInput.setAttribute('readonly', 'readonly');
          batchSizeInput.setAttribute('aria-readonly', 'true');
          batchSizeInput.min = lockedBatch;
          batchSizeInput.max = lockedBatch;

          if (maxCategoryInput) {
            const lockedMax = defaults.maxCategoryCols || lockedBatch;
            maxCategoryInput.value = lockedMax;
            maxCategoryInput.setAttribute('readonly', 'readonly');
            maxCategoryInput.setAttribute('aria-readonly', 'true');
            maxCategoryInput.min = lockedMax;
            maxCategoryInput.max = lockedMax;
          }
        } else {
          batchSizeInput.removeAttribute('readonly');
          batchSizeInput.removeAttribute('aria-readonly');
          batchSizeInput.min = '1';
          batchSizeInput.max = '50';

          if (maxCategoryInput) {
            maxCategoryInput.removeAttribute('readonly');
            maxCategoryInput.removeAttribute('aria-readonly');
            maxCategoryInput.min = '1';
            maxCategoryInput.max = '10000';
            if (enableSSR.checked && !maxCategoryInput.value) {
              maxCategoryInput.value = defaults.maxCategoryCols || MODE_DEFAULTS.csv.maxCategoryCols;
            } else if (!enableSSR.checked) {
              const stored = nonSSRState[mode] || defaults;
              maxCategoryInput.value = stored.maxCategoryCols || defaults.maxCategoryCols;
            }
          }
        }

        updateSSREnabled();
        if (ssrEnabled) {
          batchSizeInput.value = '1';
          batchSizeInput.disabled = true;
          batchSizeInput.setAttribute('title', 'SSR forces N=1');
          batchSizeInput.setAttribute('aria-disabled', 'true');
        } else {
          batchSizeInput.disabled = false;
          batchSizeInput.removeAttribute('title');
          batchSizeInput.removeAttribute('aria-disabled');
        }
      }

      function handleSSRChange() {
        if (enableSSR.checked) {
          storeCurrentNonSSRValues(currentMode);
        }
        applyMode(currentMode);
      }

      function appendPromptFields(fd) {
        const ssrPrompt = systemPromptSSRInput ? systemPromptSSRInput.value : '';
        const numericPrompt = systemPromptNumericInput ? systemPromptNumericInput.value : '';
        fd.set('enable_ssr', enableSSR.checked ? 'true' : 'false');
        fd.set('system_prompt_ssr', ssrPrompt);
        fd.set('system_prompt_numeric', numericPrompt);
        const activePrompt = enableSSR.checked ? ssrPrompt : numericPrompt;
        fd.set('system_prompt', activePrompt || '');
      }

      function buildJobFormData(action) {
        const fd = new FormData(form);
        if (autoSlowdownToggle) {
          fd.set('auto_slowdown', autoSlowdownToggle.checked ? 'true' : 'false');
        }
        const selectedMode = modeForm.querySelector('input[name="mode"]:checked').value;
        fd.set('mode', selectedMode);
        if (enableSSR.checked) {
          fd.set('batch_size', '1');
        }
        if (selectedMode === 'video') {
          fd.set('batch_size', MODE_DEFAULTS.video.batchSize);
          fd.set('max_category_cols', MODE_DEFAULTS.video.maxCategoryCols);
        }
        appendPromptFields(fd);
        if (action) {
          fd.set('action', action);
        }
        return fd;
      }

      enableSSR.addEventListener('change', () => {
        handleSSRChange();
      });

      modeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          if (!radio.checked) return;
          if (!enableSSR.checked) {
            storeCurrentNonSSRValues(currentMode);
          }
          currentMode = radio.value;
          applyMode(currentMode);
        });
      });

      batchSizeInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].batchSize = batchSizeInput.value;
      });
      if (maxCategoryInput) {
        maxCategoryInput.addEventListener('change', () => {
          if (enableSSR.checked) return;
          nonSSRState[currentMode].maxCategoryCols = maxCategoryInput.value;
        });
      }
      concurrencyInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].concurrency = concurrencyInput.value;
      });
      timeoutInput.addEventListener('change', () => {
        if (enableSSR.checked) return;
        nonSSRState[currentMode].timeout = timeoutInput.value;
      });

      handleSSRChange();

      // Settings status
      const kf = document.getElementById('keys-form');
      kf.addEventListener('submit', async (e)=>{
        e.preventDefault();
        const fd = new FormData(kf);
        fd.set('persist', document.getElementById('persist').checked ? 'true' : 'false');
        const r = await fetch('/settings', { method:'POST', body: fd });
        if(!r.ok){ alert('APIキー保存に失敗しました'); return; }
        alert('APIキーを反映しました');
      });

      const form = jobForm;

      [spreadsheetUrlInput, sheetKeywordInput, scoreSheetKeywordInput].forEach((input) => {
        if (!input) return;
        input.addEventListener('input', () => markValidationDirty());
      });

      if (checkStatusButton) {
        checkStatusButton.addEventListener('click', async (e) => {
          e.preventDefault();
          const url = spreadsheetUrlInput.value.trim();
          const sheetKeyword = sheetKeywordInput.value.trim() || 'Link';
          const scoreSheetKeyword = scoreSheetKeywordInput?.value.trim() || sheetKeyword;
          if (!url) {
            const message = 'スプレッドシートURLを入力してください。';
            showValidationBanner('error', message);
            setValidationResult(false, null, message, 'error');
            return;
          }
          showValidationBanner('info', 'スプレッドシートを検証中です...');
          checkStatusButton.disabled = true;
          try {
              const res = await fetch('/jobs/check', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  spreadsheet_url: url,
                  sheet_keyword: sheetKeyword,
                  score_sheet_keyword: scoreSheetKeyword,
                }),
              });
            let data = null;
            try {
              data = await res.json();
            } catch (err) {
              data = null;
            }
            if (!res.ok || !data || !data.ok) {
              const message = (data && data.message) || 'スプレッドシートの検証に失敗しました。';
              showValidationBanner('error', message);
              setValidationResult(false, data, message, 'error');
            } else {
              const message = data.message || 'スプレッドシートを確認しました。';
              showValidationBanner('success', message);
              setValidationResult(true, data, message, 'success');
            }
          } catch (err) {
            const message = `検証に失敗しました: ${err instanceof Error ? err.message : err}`;
            showValidationBanner('error', message);
            setValidationResult(false, null, message, 'error');
          } finally {
            checkStatusButton.disabled = false;
          }
        });
      }

      setValidationResult(false, null, '右下の CheckSheetInfo で検証してください。', 'info');

      if (queueAddButton) {
        queueAddButton.addEventListener('click', async (e) => {
          e.preventDefault();
          if(!isValidationCurrent()){
            showValidationBanner('error', 'スプレッドシート設定の検証を完了してください（右下の「CheckSheetInfo」）。');
            return;
          }
          const fd = buildJobFormData('queue');
          const res = await fetch('/jobs', { method: 'POST', body: fd });
          if (!res.ok) { alert('キュー追加に失敗'); return; }
          await refreshQueue();
          alert('キューに追加しました');
        });
      }

      if (queueAddStartButton) {
        queueAddStartButton.addEventListener('click', async (e) => {
          e.preventDefault();
          if(!isValidationCurrent()){
            showValidationBanner('error', 'スプレッドシート設定の検証を完了してください（右下の「CheckSheetInfo」）。');
            return;
          }
          const releaseButton = setButtonBusy(queueAddStartButton, '実行中...');
          lockActionButtons(true);
          showValidationBanner('info', 'ジョブを開始しています。数秒お待ちください...');
          try {
            await runWithOverlay(async () => {
              const fd = buildJobFormData('start');
              const res = await fetch('/jobs', { method: 'POST', body: fd });
              if (!res.ok) {
                let message = '開始に失敗しました。設定を確認してください。';
                try {
                  const errJson = await res.json();
                  if (errJson?.detail) {
                    message = Array.isArray(errJson.detail)
                      ? errJson.detail.map((d) => d.msg || '').join(' ')
                      : String(errJson.detail);
                  }
                } catch {}
                showValidationBanner('error', message);
                throw new Error(message);
              }
              const data = await res.json();
              currentJobId = data.job_id;
              resultSection.style.display = 'block';
              document.getElementById('job-id').textContent = currentJobId;
              resetLogView();
              await ensureQueueRunning();
              startPolling(currentJobId);
              showValidationBanner('success', 'ジョブを開始しました。右側の進捗を確認できます。');
              await refreshQueue();
            });
          } catch (err) {
            if (err instanceof Error && err.message) {
              console.error('Failed to start job', err);
            }
          } finally {
            releaseButton();
            lockActionButtons(false);
            updateQueueActionState();
          }
        });
      }

      const queueStartButton = document.getElementById('btn-queue-start');
      if (queueStartButton) {
        queueStartButton.addEventListener('click', async ()=>{
          const release = setButtonBusy(queueStartButton, '起動中...');
          try {
            await runWithOverlay(async () => {
              await fetch('/queue/start', { method:'POST' });
              await refreshQueue();
            });
          } finally {
            release();
            updateQueueActionState();
          }
        });
      }

      cancelButton.addEventListener('click', async ()=>{
        if(!currentJobId) return;
        cancelButton.disabled = true;
        try {
          const res = await fetch(`/jobs/${currentJobId}/cancel`, { method: 'POST' });
          if (!res.ok) { alert('キャンセルに失敗しました'); }
          await refreshQueue();
          await updateProgress(currentJobId);
        } finally {
          cancelButton.disabled = false;
        }
      });

      async function refreshQueue(){
        try{
          const r = await fetch('/queue');
          if(!r.ok) return;
          const j = await r.json();
          const list = document.getElementById('queue-list');
          list.innerHTML = '';
          const items = j.items || [];
          const runningId = j.current;
          queueStatus.textContent = j.running ? `稼働中: ${runningId || ''}` : '待機中';
          if (runningId) {
            currentJobId = runningId;
            resultSection.style.display = 'block';
            document.getElementById('job-id').textContent = runningId;
            cancelButton.style.display = 'inline-flex';
            startPolling(runningId);
          } else {
            cancelButton.style.display = 'none';
            currentJobId = null;
            stopPolling();
          }
          items.forEach((it, idx)=>{
            const row = document.createElement('div');
            row.className = 'row';
            row.style.alignItems = 'center';
            row.innerHTML = `<code>${it.job_id}</code> <span class="muted">[${it.mode}]</span> <span>${it.sheet_name||''}</span> <span class="muted">status: ${it.status}</span>`;
            const right = document.createElement('div');
            right.className = 'right';

            const up = document.createElement('button'); up.className='btn btn-ghost'; up.textContent='↑';
            up.onclick = async ()=>{ const pos = Math.max(0, idx-1); const fd=new FormData(); fd.set('position', pos); await fetch(`/queue/${it.job_id}/move`, {method:'POST', body:fd}); refreshQueue(); };
            const down = document.createElement('button'); down.className='btn btn-ghost'; down.textContent='↓';
            down.onclick = async ()=>{ const pos = idx+1; const fd=new FormData(); fd.set('position', pos); await fetch(`/queue/${it.job_id}/move`, {method:'POST', body:fd}); refreshQueue(); };
            const edit = document.createElement('button'); edit.className='btn btn-outline'; edit.textContent='編集';
            edit.onclick = async ()=>{
              try{
                const r = await fetch(`/jobs/${it.job_id}/config`);
                if(!r.ok){ alert('設定取得に失敗'); return; }
                const txt = await r.text();
                const cfg = JSON.parse(txt);
                // Populate form with cfg
                form.spreadsheet_url.value = cfg.spreadsheet_url;
                form.sheet_keyword.value = cfg.sheet_keyword || 'Link';
                form.score_sheet_keyword.value = cfg.score_sheet_keyword || 'Embedding';
                form.utterance_col.value = cfg.utterance_col;
                form.category_start_col.value = cfg.category_start_col;
                form.name_row.value = cfg.name_row;
                form.def_row.value = cfg.def_row;
                form.detail_row.value = cfg.detail_row;
                form.start_row.value = cfg.start_row;
                form.batch_size.value = cfg.batch_size;
                form.max_category_cols.value = cfg.max_category_cols;
                form.concurrency.value = cfg.concurrency;
                form.max_retries.value = cfg.max_retries;
                if (autoSlowdownToggle) {
                  autoSlowdownToggle.checked = !!cfg.auto_slowdown;
                }
                form.timeout_sec.value = cfg.timeout_sec;
                document.querySelector(`#mode-form input[name="mode"][value="${cfg.mode}"]`).checked = true;
                enableSSR.checked = cfg.enable_ssr !== false;
                if (systemPromptSSRInput) {
                  systemPromptSSRInput.value = cfg.ssr_system_prompt || '';
                }
                if (systemPromptNumericInput) {
                  systemPromptNumericInput.value = cfg.numeric_system_prompt || '';
                }
                updateSSREnabled();
                form.dataset.editing = it.job_id;
                alert('フォームに読み込みました。下の「編集を保存」で反映できます。');
                validation.markDirty(false);
                showValidationBanner('info', '読み込んだ設定です。右下の「CheckSheetInfo」で検証してください。');
                validation.updateCard('info', '読み込んだ設定です。右下の CheckSheetInfo で検証してください。', null);
                updateQueueActionState();
              }catch{}
            };
            const save = document.createElement('button'); save.className='btn btn-primary'; save.textContent='編集を保存';
            save.onclick = async ()=>{
              const ej = form.dataset.editing;
              if(!ej){ alert('編集対象が読み込まれていません'); return; }
              const fd = buildJobFormData();
              const r = await fetch(`/queue/${ej}/edit`, { method:'POST', body: fd });
              if(!r.ok){ alert('保存に失敗'); return; }
              alert('保存しました'); form.dataset.editing='';
              refreshQueue();
            };
            const del = document.createElement('button'); del.className='btn btn-danger'; del.textContent='削除';
            del.onclick = async ()=>{ await fetch(`/queue/${it.job_id}`, { method:'DELETE' }); refreshQueue(); };

            right.appendChild(up); right.appendChild(down); right.appendChild(edit); right.appendChild(save); right.appendChild(del);
            row.appendChild(right);
            list.appendChild(row);
          });
        }catch{}
      }

      // 初期ロード
      refreshQueue();
      setInterval(refreshQueue, 2000);

      // ログUI廃止
    </script>
  </body>
  </html>

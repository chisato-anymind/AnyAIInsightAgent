<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  <link rel="icon" href="/static/anyai/assets/AnyAI_Logo_For_Loading.png">
  <title>AnyAI Comment Enhancer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/anyai/css/main.css" />
  <script src="/static/anyai/loading-overlay.js"></script>
  <script defer src="/static/anyai/vendor/lucide.js"></script>
  <script defer src="/static/anyai/sidebar.js"></script>
  <script defer src="/static/anyai/core/anyai.js"></script>
  <style>
    #log-container {
      height: 320px;
      overflow-y: auto;
      font-family: var(--anyai-font-mono, 'Roboto Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace);
      font-size: 0.9rem;
      white-space: pre-wrap;
      background: var(--anyai-bg-subtle);
      padding: var(--anyai-space-4);
      border-radius: var(--anyai-radius-2);
      border: 1px solid var(--anyai-border);
    }

    .queue-status {
      display:flex;
      align-items:center;
      gap:var(--anyai-space-2, 8px);
      font-size:var(--anyai-fs-2, 14px);
    }

    .queue-status-label {
      color:var(--anyai-text-subtle, #5a627d);
      font-weight:600;
    }

    .queue-status-dot {
      width:8px;
      height:8px;
      border-radius:999px;
      flex:0 0 auto;
    }

    .queue-status-dot--idle {
      background:color-mix(in srgb, #fcbf49, transparent 30%);
      box-shadow:0 0 0 3px color-mix(in srgb, #fcbf49, transparent 70%);
    }

    @keyframes queue-status-pulse {
      0% { box-shadow:0 0 0 0 rgba(18, 161, 80, 0.28); }
      70% { box-shadow:0 0 0 6px rgba(18, 161, 80, 0); }
      100% { box-shadow:0 0 0 0 rgba(18, 161, 80, 0); }
    }

    .queue-status-dot--active {
      background:var(--anyai-success, #12a150);
      animation:queue-status-pulse 1.8s ease-out infinite;
    }

    .queue-chip {
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:2px 12px;
      border-radius:999px;
      font-size:var(--anyai-fs-1, 12px);
      font-weight:600;
      line-height:1.2;
      border:1px solid transparent;
    }

    .queue-chip--idle {
      background:transparent;
      border-color:transparent;
      color:color-mix(in srgb, var(--anyai-text, #1f2432), transparent 35%);
      padding:0;
    }

    .queue-chip--active {
      background:color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 82%);
      border-color:color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 58%);
      color:color-mix(in srgb, var(--anyai-primary, #2955ff), black 18%);
    }

    .queue-actions {
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }

    .queue-edit-button,
    .queue-save-button {
      position:relative;
    }

    .queue-edit-button {
      font-size:1.2rem;
      line-height:1;
      letter-spacing:-2px;
    }

    .queue-save-button {
      box-shadow:0 6px 18px rgba(45, 91, 255, 0.18);
    }

    .queue-save-button:hover,
    .queue-save-button:focus-visible {
      box-shadow:0 8px 20px rgba(45, 91, 255, 0.18);
    }

    .queue-save-button[aria-busy="true"] {
      box-shadow:0 6px 16px rgba(45, 91, 255, 0.16);
    }

    .queue-delete-button {
      box-shadow:0 6px 18px rgba(209, 67, 67, 0.18);
    }

    .queue-delete-button:hover,
    .queue-delete-button:focus-visible {
      box-shadow:0 8px 22px rgba(209, 67, 67, 0.2);
    }

    .queue-delete-button[aria-busy="true"] {
      box-shadow:0 6px 16px rgba(209, 67, 67, 0.16);
    }

    .anyai-form-actions {
      margin-top: var(--anyai-space-6, 24px);
      display: flex;
      flex-wrap: wrap;
      gap: var(--anyai-space-3, 12px);
      justify-content: center;
      align-items: center;
    }

    .anyai-form-actions .btn {
      min-width: 120px;
    }

    #queue-list .queue-row {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:var(--anyai-space-3, 12px);
      padding:var(--anyai-space-3, 12px) var(--anyai-space-4, 16px);
      border:1px solid color-mix(in srgb, var(--anyai-border), transparent 12%);
      border-radius:var(--anyai-radius-2, 12px);
      background:var(--anyai-panel, #ffffff);
    }

    #queue-list .queue-row + .queue-row {
      margin-top:var(--anyai-space-3, 12px);
    }

    .queue-row-info {
      display:flex;
      flex-direction:column;
      gap:4px;
    }

    .queue-row-meta {
      display:flex;
      flex-wrap:wrap;
      gap:var(--anyai-space-2, 8px);
      font-size:var(--anyai-fs-1, 12px);
      color:var(--anyai-text-subtle, #5a627d);
    }

    .queue-row.is-editing {
      box-shadow:0 0 0 3px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 80%);
    }

    .queue-toast {
      position: fixed;
      top: clamp(16px, 4vw, 40px);
      left: 50%;
      transform: translate(-50%, -140%);
      opacity: 0;
      pointer-events: none;
      padding: var(--anyai-space-4, 16px) var(--anyai-space-5, 20px);
      border-radius: var(--anyai-radius-2, 10px);
      font-size: var(--anyai-fs-2, 14px);
      font-weight: 600;
      background: #ffffff;
      color: var(--anyai-text, #1f2432);
      border: 1px solid color-mix(in srgb, var(--anyai-border, #dfe3f0), transparent 18%);
      border-left: 4px solid var(--queue-toast-accent, var(--anyai-primary, #2955ff));
      box-shadow: 0 16px 40px rgba(15, 23, 42, 0.18);
      min-width: min(360px, calc(100vw - 32px));
      max-width: calc(100vw - 32px);
      text-align: center;
      z-index: 120;
      transition: transform 0.25s ease, opacity 0.25s ease;
    }

    .queue-toast.is-visible {
      transform: translate(-50%, 0);
      opacity: 1;
      pointer-events: auto;
    }

    .queue-toast[data-state="success"] {
      --queue-toast-accent: var(--anyai-success, #12a150);
    }

    .queue-toast[data-state="error"] {
      --queue-toast-accent: var(--anyai-danger, #d14343);
    }

    .anyai-action-bar {
      position: fixed;
      left: 50%;
      right: auto;
      transform: translate(-50%, 0);
      bottom: clamp(var(--anyai-space-6, 24px), 6vw, var(--anyai-space-9, 64px));
      display: flex;
      justify-content: center;
      gap: var(--anyai-space-2, 8px);
      padding: var(--anyai-space-2, 8px) var(--anyai-space-3, 12px);
      background: color-mix(in srgb, var(--anyai-panel, #ffffff), transparent 4%);
      border: 1px solid color-mix(in srgb, var(--anyai-border, #dfe3f0), transparent 15%);
      border-radius: var(--anyai-radius-pill, 999px);
      box-shadow: var(--anyai-shadow, 0 1px 2px rgba(15, 23, 42, 0.08));
      z-index: 50;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .anyai-action-bar.is-hidden {
      opacity: 0;
      pointer-events: none;
      transform: translate(-50%, 16px);
    }

    .anyai-action-bar.is-empty {
      display: none;
    }

    .history-list { list-style:none; margin:0; padding:0; display:flex; flex-direction:column; gap:var(--anyai-space-2); }
    .history-list li { cursor:pointer; border:1px solid var(--anyai-border); border-radius:var(--anyai-radius-2); padding:var(--anyai-space-3) var(--anyai-space-4); transition:background .15s ease; }
    .history-list li:hover { background:var(--anyai-bg-subtle); }

    .field-inline { display:flex; align-items:center; gap:var(--anyai-space-3); }
    .field-inline label { font-weight:400; }

    .anyai-form-fields {
      gap: var(--anyai-space-3, 12px);
    }

    .field .field-hint {
      margin-top: var(--anyai-space-1, 4px);
    }

    .sheet-selection-grid {
      width: 100%;
      grid-template-columns: minmax(0, 1fr);
      gap: var(--anyai-space-3);
      align-items: start;
    }

    .sheet-selection-grid > .field:first-of-type {
      grid-column: 1 / -1;
    }

    .sheet-selection-grid details.field-info-inline .info-panel {
      width: 100%;
      box-sizing: border-box;
      font-size: var(--anyai-fs-1);
    }

    .sheet-selection-grid .field {
      position: relative;
    }

    .sheet-selection-grid .field select {
      width: 100%;
      border-radius: var(--anyai-radius-2);
      border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 20%);
      background:
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'%3E%3Cpath fill='none' stroke='%23545d72' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2' d='m3 5 4 4 4-4'/%3E%3C/svg%3E")
          right 12px center / 14px 14px no-repeat,
        #ffffff;
      padding: 6px 40px 6px 12px;
      font: inherit;
      line-height: 1.4;
      color: inherit;
      appearance: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, color 0.2s ease;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.02);
    }

    .sheet-selection-grid .field select:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      background:
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'%3E%3Cpath fill='none' stroke='%238490a8' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2' d='m3 5 4 4 4-4'/%3E%3C/svg%3E")
          right 12px center / 14px 14px no-repeat,
        #f5f7fb;
      color: color-mix(in srgb, currentColor, transparent 25%);
      border-color: color-mix(in srgb, var(--anyai-border), transparent 10%);
    }

    .sheet-selection-grid .field select:not(:disabled):hover {
      border-color: color-mix(in srgb, var(--anyai-border), var(--anyai-primary, #2955ff) 28%);
      box-shadow: 0 4px 10px rgba(36, 43, 68, 0.06);
    }

    .sheet-selection-grid .field select:not(:disabled):focus-visible {
      outline: none;
      border-color: color-mix(in srgb, var(--anyai-border), var(--anyai-primary, #2955ff) 40%);
      box-shadow:
        0 0 0 4px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 85%),
        0 6px 18px rgba(36, 43, 68, 0.08);
    }

    .sheet-selection-grid .field select option,
    .sheet-selection-grid .field select optgroup {
      background: #ffffff;
      color: var(--anyai-text, #1f2432);
    }

    .custom-select {
      position: relative;
      width: 100%;
    }

    .custom-select-native {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      border: 0;
      clip: rect(0 0 0 0);
      clip-path: inset(100%);
      overflow: hidden;
      white-space: nowrap;
    }

    .custom-select-toggle {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--anyai-space-3);
      padding: 6px 40px 6px 12px;
      border-radius: var(--anyai-radius-2);
      border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 20%);
      background: #ffffff;
      color: var(--anyai-text, #1f2432);
      font: inherit;
      line-height: 1.4;
      cursor: pointer;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
      position: relative;
    }

    .custom-select-toggle::after {
      content: "";
      width: 14px;
      height: 14px;
      flex: 0 0 auto;
      background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 14 14'%3E%3Cpath fill='none' stroke='%23545d72' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.2' d='m3 5 4 4 4-4'/%3E%3C/svg%3E") center / contain no-repeat;
      transition: transform 0.2s ease;
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
    }

    .custom-select-label {
      flex: 1 1 auto;
      text-align: left;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      padding-right: var(--anyai-space-2);
    }

    .custom-select.is-open .custom-select-toggle {
      border-radius: var(--anyai-radius-2) var(--anyai-radius-2) 0 0;
      border-color: color-mix(in srgb, var(--anyai-border), var(--anyai-primary, #2955ff) 40%);
      box-shadow:
        0 0 0 4px color-mix(in srgb, var(--anyai-primary, #2955ff), transparent 85%),
        0 10px 30px rgba(36, 43, 68, 0.08);
    }

    .custom-select.is-open .custom-select-toggle::after {
      transform: rotate(180deg);
    }

    .custom-select:not(.has-value) .custom-select-label {
      color: color-mix(in srgb, var(--anyai-text), transparent 35%);
    }

    .custom-select.is-disabled .custom-select-toggle {
      cursor: not-allowed;
      background: #f5f7fb;
      color: color-mix(in srgb, var(--anyai-text), transparent 35%);
    }

    .custom-select.is-disabled .custom-select-toggle::after {
      filter: grayscale(1) opacity(0.65);
    }

    .custom-select-menu {
      position: absolute;
      left: 0;
      top: calc(100% - 1px);
      width: 100%;
      background: #ffffff;
      border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 20%);
      border-top: 0;
      border-radius: 0 0 var(--anyai-radius-2) var(--anyai-radius-2);
      box-shadow: 0 22px 40px rgba(36, 43, 68, 0.16);
      max-height: 280px;
      overflow-y: auto;
      padding: 4px 0;
      z-index: 70;
      opacity: 0;
      pointer-events: none;
      transform: translateY(6px);
      transition: opacity 0.18s ease, transform 0.18s ease;
    }

    .custom-select.is-open .custom-select-menu {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    .custom-select-option {
      display: flex;
      align-items: center;
      width: 100%;
      padding: 10px 14px;
      background: transparent;
      border: 0;
      font: inherit;
      color: inherit;
      text-align: left;
      cursor: pointer;
      transition: background-color 0.15s ease, color 0.15s ease;
    }

    .custom-select-option:hover,
    .custom-select-option:focus-visible {
      outline: none;
      background: color-mix(in srgb, var(--anyai-primary), transparent 90%);
    }

    .custom-select-option.is-selected {
      background: color-mix(in srgb, var(--anyai-primary), transparent 85%);
      font-weight: 600;
    }

    .custom-select-option.is-disabled {
      color: color-mix(in srgb, var(--anyai-text), transparent 45%);
      cursor: not-allowed;
    }

    .custom-select-option.is-disabled:hover {
      background: transparent;
    }

    .anyai-form-section {
      display: flex;
      flex-direction: column;
      gap: var(--anyai-space-3, 12px);
      background: var(--anyai-form-band, #f1f5f9);
      border-radius: var(--anyai-radius-2, 12px);
      padding: var(--anyai-space-5, 20px) var(--anyai-space-6, 28px);
      border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 85%);
    }

    .anyai-form-section + .anyai-form-section {
      margin-top: 0;
    }

    .anyai-form-group {
      display: flex;
      flex-direction: column;
      gap: var(--anyai-space-3, 12px);
      background: none;
      border: 0;
      border-radius: 0;
      padding: 0;
    }

    .anyai-form-section > header,
    .anyai-form-group > header {
      margin-bottom: 0;
    }

    .anyai-form-section > header > h2.mt-0,
    .anyai-form-group > header > h3.mt-0 {
      margin-bottom: 0;
    }

    .field-with-action {
      display: flex;
      align-items: stretch;
      gap: 0;
    }

    .field-with-action .input {
      flex: 1 1 auto;
      min-width: 0;
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
      border-right: 0;
    }

    .field-with-action .input-action-btn {
      flex: 0 0 auto;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 var(--anyai-space-4, 16px);
      min-width: 72px;
      border-radius: 0 var(--anyai-radius-2, 12px) var(--anyai-radius-2, 12px) 0;
      border-left: 0;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      font-weight: 600;
      transition: transform 0.15s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    }

    .field-with-action .input-action-btn:not(.btn-soft-accent) {
      border: none;
      box-shadow: 0 4px 10px rgba(31, 36, 50, 0.12);
    }

    .field-with-action .input-action-btn:not(.btn-soft-accent):hover,
    .field-with-action .input-action-btn:not(.btn-soft-accent):focus-visible {
      box-shadow: 0 6px 16px rgba(31, 36, 50, 0.16);
      outline: none;
    }

    .field-with-action .input-action-btn.btn-soft-accent:hover,
    .field-with-action .input-action-btn.btn-soft-accent:focus-visible {
      transform: translateY(-1px);
    }

    .field-with-action .input-action-btn.btn-soft-accent {
      border-left: 0;
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
    }

    .sheet-selection-grid .field details.field-info-inline {
      margin-top: var(--anyai-space-2);
    }

    .sheet-selection-grid .field details.field-info-inline .info-panel {
      margin-top: 0;
      padding: var(--anyai-space-3) var(--anyai-space-4);
      border-radius: 0 0 var(--anyai-radius-2) var(--anyai-radius-2);
      border: 1px solid color-mix(in srgb, var(--anyai-border), transparent 25%);
      border-top: 0;
      background: #ffffff;
      box-shadow: 0 16px 30px rgba(36, 43, 68, 0.12);
    }

    .sheet-selection-grid .field details.field-info-inline[open] .info-toggle-icon {
      background: var(--anyai-primary, #4a63ff);
      color: var(--anyai-text-inverse, #ffffff);
    }

    .sheet-selection-grid .field .field-hint {
      margin-top: var(--anyai-space-1);
    }

    @media (min-width: 960px) {
      .sheet-selection-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .sheet-selection-grid > .field:first-of-type {
        grid-column: 1 / -1;
      }
    }

    .input-row {
      display: flex;
      align-items: center;
      gap: var(--anyai-space-2);
    }

    .input-row .input {
      flex: 1;
    }

    .input-row.input-row-compact {
      gap: var(--anyai-space-2);
    }

    @media (min-width: 720px) {
      .sheet-selection-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    .message {
      padding: var(--anyai-space-3) var(--anyai-space-4);
      border-radius: var(--anyai-radius-2);
      font-size: 0.9rem;
      border: 1px solid transparent;
    }

    .message[data-state="success"] {
      background: color-mix(in srgb, var(--anyai-success), white 90%);
      color: var(--anyai-success-900, var(--anyai-success));
      border-color: color-mix(in srgb, var(--anyai-success), transparent 60%);
    }

    .message[data-state="error"] {
      background: color-mix(in srgb, var(--anyai-danger), white 90%);
      color: var(--anyai-danger-900, var(--anyai-danger));
      border-color: color-mix(in srgb, var(--anyai-danger), transparent 60%);
    }

    .message[data-state="info"] {
      background: var(--anyai-bg-subtle);
      color: var(--anyai-text-subtle);
      border-color: var(--anyai-border);
    }

    .model-grid {
      display: grid;
      gap: var(--anyai-space-4);
    }

    @media (min-width: 640px) {
      .model-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }

    @media (max-width: 720px) {
      #log-container { height: 240px; }
      .queue-content { flex-direction:column; }
      .anyai-form-actions {
        flex-direction: column;
        align-items: stretch;
      }

      .anyai-form-actions .btn {
        width: 100%;
      }
    }
  </style>
</head>
<body>
    <div class="anyai-layout">
      <aside class="anyai-sidebar" data-active-tool="comment-enhancer"></aside>
      <main class="anyai-content">
      <div class="anyai-app">
        <section class="anyai-app-primary" aria-labelledby="enhancer-heading">
          <h1 id="enhancer-heading" class="mt-0 page-title-with-icon">
            <span class="page-title-icon" aria-hidden="true"><i data-lucide="message-circle"></i></span>
            <span>Commnet Enhancer</span>
          </h1>
          <p class="field-hint">スプレッドシートのコメント列を取り込み、指定モデルで改善案を生成します。</p>
          <form id="enhancer-form" class="anyai-form" aria-labelledby="enhancer-config-heading" autocomplete="off">
            <section class="anyai-form-section" aria-labelledby="sheet-heading">
              <header>
                <h2 id="sheet-heading" class="mt-0">入力設定</h2>
                <p class="field-hint">スコアリングと同じ形式でスプレッドシートとコメント出力先を設定します。</p>
              </header>
              <div class="anyai-form-fields sheet-selection-grid">
                <div class="field">
                  <label for="spreadsheet_url">スプレッドシートURL / ID</label>
                  <p class="field-hint">対象のGoogleシートURLまたはIDを入力し、Setでシート一覧を読み込みます。</p>
                  <div class="field-with-action">
                    <input class="input" type="text" id="spreadsheet_url" name="spreadsheet_url" placeholder="https://docs.google.com/spreadsheets/d/..." required data-sharkid="__3">
                    <button type="button" class="btn btn-primary input-action-btn" id="btn-spreadsheet-set">Set</button>
                  </div>
                </div>
                <div class="field" id="analysis-sheet-field">
                  <label for="sheet_keyword">分析テキスト シート</label>
                  <select id="sheet_keyword" name="sheet_keyword" disabled data-placeholder="Setで読み込んでください" class="js-custom-select">
                    <option value="">Setで読み込んでください</option>
                  </select>
                  <p class="field-hint">Setで取得したシート一覧から選択します。</p>
                  <details class="field-info field-info-inline">
                    <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                    <div class="info-panel" id="sheet-keyword-help">自然言語の分析結果を書き込むシート名に含まれるキーワード。該当シートが1つのみである必要があります。</div>
                  </details>
                </div>
                <div class="field" id="output-sheet-field">
                  <label for="score_sheet_keyword">コメント出力 シート</label>
                  <select id="score_sheet_keyword" name="score_sheet_keyword" disabled data-placeholder="Setで読み込んでください" class="js-custom-select">
                    <option value="">Setで読み込んでください</option>
                  </select>
                  <p class="field-hint">Setで取得したシート一覧から選択します。</p>
                  <details class="field-info field-info-inline">
                    <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                    <div class="info-panel" id="score-sheet-keyword-help">分析テキストと同じ位置にコメントを書き込むシート名に含まれるキーワード。</div>
                  </details>
                </div>
                <input type="hidden" id="sheet_gid" name="sheet_gid" value="">
                <input type="hidden" id="score_sheet_gid" name="score_sheet_gid" value="">
              </div>
              <div id="validation-banner" class="validation-banner" role="status" aria-live="polite"></div>
              <div class="field">
                <label for="workers">並列処理数</label>
                <p class="field-hint">同時実行するワーカー数（推奨: 50）。</p>
                <input class="input" type="number" id="workers" value="50" min="1" max="200">
                <details class="field-info">
                  <summary class="info-toggle"><span class="info-toggle-icon" aria-hidden="true">i</span><span>詳細</span></summary>
                  <div class="info-panel">429 対策が必要な場合は値を下げてください。最大 200 まで指定できます。</div>
                </details>
              </div>
            </section>

            <section class="anyai-form-section" aria-labelledby="model-heading">
              <header>
                <h2 id="model-heading" class="mt-0">モデル選択</h2>
                <p class="field-hint">Scoring UI と同じ選択肢からメインモデルを指定できます。</p>
              </header>
              <div class="model-grid">
                <div class="field">
                  <label for="model-select">利用モデル</label>
                  <select id="model-select" class="js-custom-select" data-placeholder="モデルを選択">
                    <optgroup label="Gemini">
                      <option value="gemini-flash-lite-latest" selected>Gemini Flash Lite (latest)</option>
                      <option value="gemini-flash-latest">Gemini Flash (latest)</option>
                      <option value="gemini-pro-latest">Gemini Pro (latest)</option>
                    </optgroup>
                    <optgroup label="OpenAI">
                      <option value="gpt-5-nano">GPT-5 Nano</option>
                      <option value="gpt-4.1-nano">GPT-4.1 Nano</option>
                      <option value="gpt-4.1">GPT-4.1</option>
                    </optgroup>
                  </select>
                  <p class="field-hint">Gemini 系はテキスト生成に Gemini API、GPT 系は OpenAI API を利用します。</p>
                </div>
                <div class="field">
                  <label for="fallback-model">フォールバックモデル</label>
                  <select id="fallback-model" class="js-custom-select" data-placeholder="フォールバックなし（任意）">
                    <option value="">フォールバックなし</option>
                    <optgroup label="Gemini">
                      <option value="gemini-flash-lite-latest">Gemini Flash Lite (latest)</option>
                      <option value="gemini-flash-latest">Gemini Flash (latest)</option>
                      <option value="gemini-pro-latest">Gemini Pro (latest)</option>
                    </optgroup>
                    <optgroup label="OpenAI">
                      <option value="gpt-5-nano">GPT-5 Nano</option>
                      <option value="gpt-4.1-nano">GPT-4.1 Nano</option>
                      <option value="gpt-4.1">GPT-4.1</option>
                    </optgroup>
                  </select>
                  <p class="field-hint">メインモデルが失敗した場合に、ここで選択したモデルで再実行します。</p>
                </div>
              </div>
            </section>
            <div class="anyai-form-actions" id="enhancer-action-area">
              <button type="button" class="btn btn-outline" id="btn-refresh-queue">再取得</button>
              <button type="button" class="btn btn-outline" id="stop-button" disabled>停止</button>
              <button type="submit" class="btn btn-primary" id="run-button">実行</button>
            </div>
          </form>
        </section>

        <aside class="anyai-app-support">
          <section class="anyai-support-card">
            <div class="support-header">
              <h2 class="mt-0">最近のシート</h2>
            </div>
            <p class="field-hint" id="history-empty">実行履歴はまだありません。</p>
            <ul id="history-list" class="history-list"></ul>
          </section>

          <div class="anyai-support-card support-metrics">
            <div class="support-header">
              <h2 class="mt-0">ジョブキュー</h2>
              <button id="btn-queue-start" class="btn btn-primary" type="button">キュー開始</button>
            </div>
            <div id="queue-status" class="queue-status"></div>
            <div id="queue-list" class="stack-sm"></div>
          </div>

          <section class="anyai-support-card">
            <h2 class="mt-0">Execution Log</h2>
            <div id="log-container"><span class="text-subtle">Awaiting configuration...</span></div>
          </section>
        </aside>
      </div>
    </main>
  </div>

  <div class="anyai-action-bar" role="region" aria-label="コメント改善操作">
    <button type="button" class="btn btn-outline" data-proxy-for="btn-refresh-queue">再取得</button>
    <button type="button" class="btn btn-outline" data-proxy-for="stop-button">停止</button>
    <button type="button" class="btn btn-primary" data-proxy-for="run-button">実行</button>
  </div>

  <div id="queue-toast" class="queue-toast" role="status" aria-live="polite" aria-hidden="true"></div>

  <script>
    const loadingOverlay = window.AnyAILoading || {
      run: async (task) => task(),
      wrap: async (promise) => promise,
      show: () => {},
      hide: () => {},
      requireKeys: async () => true,
    };

    const form = document.getElementById('enhancer-form');
    const logContainer = document.getElementById('log-container');
    const runButton = document.getElementById('run-button');
    const stopButton = document.getElementById('stop-button');
    const sheetInput = document.getElementById('spreadsheet_url');
    const sheetSetButton = document.getElementById('btn-spreadsheet-set');
    const validationBanner = document.getElementById('validation-banner');
    const sheetKeywordInput = document.getElementById('sheet_keyword');
    const scoreSheetKeywordInput = document.getElementById('score_sheet_keyword');
const sheetGidInput = document.getElementById('sheet_gid');
const scoreSheetGidInput = document.getElementById('score_sheet_gid');
    const historyList = document.getElementById('history-list');
    const historyEmpty = document.getElementById('history-empty');
    const queueStatus = document.getElementById('queue-status');
    const queueList = document.getElementById('queue-list');
    const queueStartButton = document.getElementById('btn-queue-start');
    const refreshQueueButton = document.getElementById('btn-refresh-queue');
    const modelSelect = document.getElementById('model-select');
    const fallbackSelect = document.getElementById('fallback-model');
    const workersInput = document.getElementById('workers');
    const queueToast = document.getElementById('queue-toast');
    let queueToastTimer = null;
    const actionBar = document.querySelector('.anyai-action-bar');
    const actionProxyButtons = actionBar ? Array.from(actionBar.querySelectorAll('[data-proxy-for]')) : [];
    const actionProxyObservers = new Map();
    const primaryPanel = document.querySelector('.anyai-app-primary');
    const formActions = document.getElementById('enhancer-action-area');
    let actionBarResizeObserver = null;
    let actionBarIntersectionObserver = null;
    let actionBarInitialized = false;
function hideQueueToast() {
  if (!queueToast) return;
  queueToast.classList.remove('is-visible');
  queueToast.setAttribute('aria-hidden', 'true');
  window.setTimeout(() => {
    if (!queueToast.classList.contains('is-visible')) {
      queueToast.textContent = '';
      queueToast.removeAttribute('data-state');
    }
  }, 220);
}

function showQueueToast(message, options = {}) {
  if (!queueToast) {
    if (options.state === 'error') {
      log(`-> ${message}`, true);
    } else {
      log(`-> ${message}`);
    }
    return;
  }
  const state = options.state || 'success';
  const duration = typeof options.duration === 'number' ? options.duration : 3000;
  if (queueToastTimer) {
    clearTimeout(queueToastTimer);
    queueToastTimer = null;
  }
  queueToast.setAttribute('data-state', state);
  queueToast.textContent = message || '';
  queueToast.setAttribute('aria-hidden', 'false');
  void queueToast.offsetWidth;
  queueToast.classList.add('is-visible');
  if (duration > 0) {
    queueToastTimer = window.setTimeout(() => {
      hideQueueToast();
    }, duration);
  }
}

    if (queueToast) {
      queueToast.addEventListener('click', () => {
        hideQueueToast();
      });
    }

    function getProxyTarget(proxy) {
      if (!proxy) return null;
      const targetId = proxy.dataset.proxyFor;
      return targetId ? document.getElementById(targetId) : null;
    }

    function positionActionBar() {
      if (!actionBar || !primaryPanel) return;
      const hasVisibleProxy = actionProxyButtons.some((proxy) => proxy.style.display !== 'none');
      if (!hasVisibleProxy) return;
      const panelRect = primaryPanel.getBoundingClientRect();
      if (panelRect.width <= 0) return;
      actionBar.style.removeProperty('width');
      const naturalWidth = actionBar.offsetWidth;
      const maxWidth = Math.max(panelRect.width - 24, 0);
      const finalWidth = maxWidth > 0 ? Math.min(naturalWidth, maxWidth) : naturalWidth;
      actionBar.style.width = `${finalWidth}px`;
      actionBar.style.left = `${panelRect.left + panelRect.width / 2}px`;
    }

    function updateProxyState(proxy) {
      if (!proxy) return;
      const target = getProxyTarget(proxy);
      if (!target) {
        proxy.disabled = true;
        proxy.style.display = 'none';
        proxy.removeAttribute('aria-busy');
        return;
      }

      const targetStyle = window.getComputedStyle(target);
      const hidden =
        targetStyle.display === 'none' ||
        targetStyle.visibility === 'hidden' ||
        target.hasAttribute('hidden');
      proxy.style.display = hidden ? 'none' : '';
      proxy.disabled = target.disabled || hidden;
      if (!hidden) {
        proxy.textContent = target.textContent;
      }
      if (target.hasAttribute('aria-busy')) {
        proxy.setAttribute('aria-busy', target.getAttribute('aria-busy'));
      } else {
        proxy.removeAttribute('aria-busy');
      }
    }

    function updateActionBarVisibility() {
      if (!actionBar) return;
      const hasProxies = actionProxyButtons.length > 0;
      const hasEnabled = actionProxyButtons.some((proxy) => !proxy.disabled);
      actionBar.classList.toggle('is-empty', !hasProxies);
      actionBar.classList.toggle('is-hidden', !hasEnabled);
      if (hasEnabled) {
        positionActionBar();
      }
    }

    function syncActionProxies() {
      if (!actionBar) return;
      actionProxyButtons.forEach(updateProxyState);
      updateActionBarVisibility();
    }

    function initActionProxies() {
      if (!actionBar || !actionProxyButtons.length) return;
      actionProxyButtons.forEach((proxy) => {
        const target = getProxyTarget(proxy);
        proxy.addEventListener('click', (event) => {
          event.preventDefault();
          const currentTarget = getProxyTarget(proxy);
          if (currentTarget && !currentTarget.disabled) {
            currentTarget.click();
          }
        });

        if (target) {
          const observer = new MutationObserver(() => updateProxyState(proxy));
          observer.observe(target, { attributes: true, attributeFilter: ['disabled', 'aria-busy', 'hidden', 'style'] });
          actionProxyObservers.set(proxy, observer);
        }

        updateProxyState(proxy);
      });

      if (!actionBarInitialized) {
        if ('ResizeObserver' in window && primaryPanel) {
          actionBarResizeObserver = new ResizeObserver(() => positionActionBar());
          actionBarResizeObserver.observe(primaryPanel);
        }
        window.addEventListener('resize', positionActionBar);
        window.addEventListener('orientationchange', positionActionBar);
        if ('IntersectionObserver' in window && formActions) {
          actionBarIntersectionObserver = new IntersectionObserver(
            (entries) => {
              entries.forEach((entry) => {
                positionActionBar();
                if (entry.isIntersecting) {
                  actionBar.classList.add('is-hidden');
                } else {
                  actionBar.classList.remove('is-hidden');
                }
              });
            },
            { threshold: 0.2 }
          );
          actionBarIntersectionObserver.observe(formActions);
        }
        actionBarInitialized = true;
      }

      updateActionBarVisibility();
    }

    function setStopButtonsEnabled(enabled) {
      if (stopButton) {
        stopButton.disabled = !enabled;
        stopButton.setAttribute('aria-disabled', enabled ? 'false' : 'true');
      }
      syncActionProxies();
    }
    setStopButtonsEnabled(false);

    const customSelectRegistry = new WeakMap();
    setupCustomSelect(sheetKeywordInput);
    setupCustomSelect(scoreSheetKeywordInput);
    setupCustomSelect(modelSelect);
    setupCustomSelect(fallbackSelect);

    initActionProxies();
    syncActionProxies();

    let currentProcessId = null;
    let eventSource = null;
    let isJobRunning = false;
    const keyStatus = { openai: false, gemini: false };
    const missingKeyNotice = { openai: false, gemini: false };
    let resolvedSpreadsheetId = '';
    let resolvedSheets = [];
    let isSettingSheets = false;
    let pendingSheetSelection = null;
    let queueRefreshTimer = null;
    let latestQueueItems = [];
    let editingJobId = '';

    const HISTORY_KEY = 'anyai_sheet_history_v4';
    const MAX_HISTORY = 10;

    function log(message, isError = false) {
      const timestamp = new Date().toLocaleTimeString();
      const line = document.createElement('div');
      line.innerHTML = `<span class="text-subtle">[${timestamp}]</span> <span style="color:${isError ? 'var(--anyai-color-danger-700)' : 'inherit'};">${message}</span>`;
      logContainer.appendChild(line);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    function detectProvider(modelValue) {
      if (!modelValue) return 'openai';
      return modelValue.startsWith('gemini') ? 'gemini' : 'openai';
    }

    function setupCustomSelect(select) {
      if (!select || customSelectRegistry.has(select)) return;

      const placeholder = select.dataset.placeholder || '';
      const wrapper = document.createElement('div');
      wrapper.className = 'custom-select';

      const toggle = document.createElement('button');
      toggle.type = 'button';
      toggle.className = 'custom-select-toggle';
      toggle.setAttribute('aria-haspopup', 'listbox');
      toggle.setAttribute('aria-expanded', 'false');

      const label = document.createElement('span');
      label.className = 'custom-select-label';
      label.textContent = placeholder;
      toggle.appendChild(label);

      const menu = document.createElement('div');
      menu.className = 'custom-select-menu';
      menu.setAttribute('role', 'listbox');
      menu.hidden = true;
      menu.tabIndex = -1;

      const menuId = `${select.id || `custom-select-${Math.random().toString(36).slice(2)}`}-menu`;
      menu.id = menuId;
      toggle.setAttribute('aria-controls', menuId);
      toggle.setAttribute('role', 'combobox');

      const parent = select.parentNode;
      parent.insertBefore(wrapper, select);
      wrapper.appendChild(toggle);
      wrapper.appendChild(menu);
      wrapper.appendChild(select);

      select.classList.add('custom-select-native');
      select.tabIndex = -1;
      select.setAttribute('aria-hidden', 'true');

      const state = {
        select,
        wrapper,
        toggle,
        label,
        menu,
        placeholder,
        isOpen: false,
        focusIndex: -1,
        optionButtons: [],
        observers: [],
      };

      function refreshLabel() {
        const selected = Array.from(select.selectedOptions || [])[0];
        const text = selected ? selected.textContent : '';
        label.textContent = text || state.placeholder || '';
        state.wrapper.classList.toggle('has-value', Boolean(selected && selected.value));
      }

      function syncSelectedClass() {
        const value = select.value;
        state.optionButtons.forEach((btn) => {
          const isSelected = btn.dataset.value === value;
          btn.classList.toggle('is-selected', isSelected);
          btn.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        });
      }

      function focusOption(index) {
        const enabledOptions = state.optionButtons.filter((btn) => !btn.disabled);
        if (!enabledOptions.length) return;
        const clamped = Math.max(0, Math.min(index, enabledOptions.length - 1));
        const target = enabledOptions[clamped];
        if (!target) return;
        target.focus();
        if (!target.id) {
          const rawIndex = Math.max(0, state.optionButtons.indexOf(target));
          target.id = `${state.menu.id}-option-${rawIndex}`;
        }
        state.toggle.setAttribute('aria-activedescendant', target.id);
        state.focusIndex = clamped;
        const containerRect = state.menu.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();
        if (targetRect.top < containerRect.top) {
          state.menu.scrollTop -= containerRect.top - targetRect.top + 4;
        } else if (targetRect.bottom > containerRect.bottom) {
          state.menu.scrollTop += targetRect.bottom - containerRect.bottom + 4;
        }
      }

      function focusSelected() {
        const enabledOptions = state.optionButtons.filter((btn) => !btn.disabled);
        const index = enabledOptions.findIndex((btn) => btn.dataset.value === select.value);
        if (index >= 0) {
          focusOption(index);
        } else {
          focusOption(0);
        }
      }

      function closeMenu({ focusToggle = false } = {}) {
        if (!state.isOpen) return;
        state.isOpen = false;
        state.wrapper.classList.remove('is-open');
        state.menu.hidden = true;
        state.toggle.setAttribute('aria-expanded', 'false');
        state.toggle.removeAttribute('aria-activedescendant');
        state.focusIndex = -1;
        document.removeEventListener('pointerdown', handleDocumentPointer, true);
        document.removeEventListener('keydown', handleDocumentKeydown, true);
        if (focusToggle) {
          state.toggle.focus();
        }
      }

      function handleDocumentPointer(event) {
        if (state.wrapper.contains(event.target)) return;
        closeMenu();
      }

      function handleDocumentKeydown(event) {
        if (event.key === 'Escape') {
          event.preventDefault();
          closeMenu({ focusToggle: true });
        }
      }

      function buildMenu() {
        state.optionButtons.forEach((btn) => btn.remove());
        state.optionButtons = [];

        state.optionButtons = Array.from(select.options || []).map((option) => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'custom-select-option';
          button.dataset.value = option.value;
          button.textContent = option.textContent || '';
          button.disabled = option.disabled;
          button.setAttribute('role', 'option');

          if (option.dataset.sheetId) {
            button.dataset.sheetId = option.dataset.sheetId;
          }

          button.addEventListener('click', () => {
            if (option.disabled) return;
            select.value = option.value;
            select.dispatchEvent(new Event('change', { bubbles: true }));
            closeMenu({ focusToggle: true });
          });

          button.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              button.click();
            } else if (event.key === 'ArrowUp') {
              event.preventDefault();
              focusOption(state.focusIndex - 1);
            } else if (event.key === 'ArrowDown') {
              event.preventDefault();
              focusOption(state.focusIndex + 1);
            } else if (event.key === 'Home') {
              event.preventDefault();
              focusOption(0);
            } else if (event.key === 'End') {
              event.preventDefault();
              const enabled = state.optionButtons.filter((btn) => !btn.disabled);
              focusOption(enabled.length - 1);
            } else if (event.key === 'Escape') {
              event.preventDefault();
              closeMenu({ focusToggle: true });
            }
          });
          state.menu.appendChild(button);
          return button;
        });
        syncSelectedClass();
      }

      function openMenu() {
        if (state.isOpen || select.disabled) return;
        buildMenu();
        state.isOpen = true;
        state.wrapper.classList.add('is-open');
        state.menu.hidden = false;
        state.toggle.setAttribute('aria-expanded', 'true');
        document.addEventListener('pointerdown', handleDocumentPointer, true);
        document.addEventListener('keydown', handleDocumentKeydown, true);
        requestAnimationFrame(() => {
          focusSelected();
        });
      }

      function syncDisabled() {
        const disabled = select.disabled;
        state.toggle.disabled = disabled;
        state.toggle.setAttribute('aria-disabled', disabled ? 'true' : 'false');
        state.wrapper.classList.toggle('is-disabled', disabled);
        if (disabled) {
          closeMenu();
        }
      }

      state.toggle.addEventListener('click', () => {
        if (state.isOpen) {
          closeMenu();
        } else {
          openMenu();
        }
      });

      state.toggle.addEventListener('keydown', (event) => {
        if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
          event.preventDefault();
          openMenu();
        }
      });

      state.menu.addEventListener('focusout', (event) => {
        if (!state.wrapper.contains(event.relatedTarget)) {
          closeMenu();
        }
      });

      select.addEventListener('change', () => {
        refreshLabel();
        syncSelectedClass();
      });

      const optionObserver = new MutationObserver(() => {
        buildMenu();
        refreshLabel();
      });
      optionObserver.observe(select, { childList: true });

      const attributeObserver = new MutationObserver(() => {
        syncDisabled();
      });
      attributeObserver.observe(select, { attributes: true, attributeFilter: ['disabled'] });

      state.observers.push(optionObserver, attributeObserver);

      customSelectRegistry.set(select, {
        state,
        refreshLabel,
        syncDisabled,
        syncSelectedClass,
        setPlaceholder(placeholderText) {
          state.placeholder = placeholderText || '';
          if (!select.value) {
            state.label.textContent = state.placeholder;
          }
        },
      });

      refreshLabel();
      syncDisabled();
      buildMenu();
    }

    function updateCustomSelectPlaceholder(select, placeholderText) {
      const entry = customSelectRegistry.get(select);
      if (!entry) return;
      entry.state.placeholder = placeholderText || '';
      if (!select.value) {
        entry.state.label.textContent = entry.state.placeholder;
      }
      entry.syncSelectedClass();
    }

    function syncCustomSelectDisabled(select) {
      const entry = customSelectRegistry.get(select);
      if (!entry) return;
      entry.syncDisabled();
    }

    function refreshCustomSelect(select) {
      const entry = customSelectRegistry.get(select);
      if (!entry) return;
      entry.refreshLabel();
      entry.syncSelectedClass();
    }

    function extractKeyReady(info) {
      if (typeof info === 'boolean') return info;
      if (info && typeof info === 'object' && 'ready' in info) {
        return Boolean(info.ready);
      }
      return Boolean(info);
    }

    function sheetSelectionsReady() {
      const sheetValue = parseSheetValue(sheetInput?.value);
      if (!sheetValue) return false;
      if (!sheetKeywordInput || !scoreSheetKeywordInput) return false;
      return Boolean(sheetKeywordInput.value) && Boolean(scoreSheetKeywordInput.value);
    }

    function updateRunButtonAvailability() {
      let disabled = false;
      if (isJobRunning || !modelSelect || !sheetSelectionsReady()) {
        disabled = true;
      } else {
        const provider = detectProvider(modelSelect.value);
        disabled = !keyStatus[provider];
      }
      if (runButton) {
        runButton.disabled = disabled;
      }
      syncActionProxies();
    }

    function maybeLogMissing(provider) {
      if (keyStatus[provider]) {
        missingKeyNotice[provider] = false;
        return;
      }
      if (missingKeyNotice[provider]) return;
      if (provider === 'gemini') {
        log('-> Gemini APIキーが未設定です。左メニューの「API」で登録してください。', true);
      } else {
        log('-> OpenAI APIキーが未設定です。左メニューの「API」で登録してください。', true);
      }
      missingKeyNotice[provider] = true;
    }

    async function refreshKeyStatus(showLog = false) {
      try {
        const resp = await fetch('/settings/status');
        if (!resp.ok) throw new Error(`status ${resp.status}`);
        const data = await resp.json();
        keyStatus.openai = extractKeyReady(data?.keys?.openai);
        keyStatus.gemini = extractKeyReady(data?.keys?.gemini);
        if (showLog) {
          log('-> APIキーの状態を更新しました。');
        }
      } catch (error) {
        if (showLog) {
          log(`-> APIキー状態の取得に失敗: ${error}`, true);
        }
      } finally {
        updateRunButtonAvailability();
        if (modelSelect) {
          maybeLogMissing(detectProvider(modelSelect.value));
        }
      }
    }

    function clearEditingState() {
      if (form && form.dataset) {
        delete form.dataset.editing;
      }
      editingJobId = '';
    }

    function renderQueueStatus(data) {
      if (!queueStatus) return;
      queueStatus.innerHTML = '';
      const isRunning = Boolean(data && data.running);
      const runningId = data && (data.current || data.running_job_id);
      const label = document.createElement('span');
      label.className = 'queue-status-label';
      label.textContent = isRunning ? '稼働中' : '待機中';
      const dot = document.createElement('span');
      dot.className = `queue-status-dot ${isRunning ? 'queue-status-dot--active' : 'queue-status-dot--idle'}`;
      const chip = document.createElement('span');
      chip.className = `queue-chip ${isRunning ? 'queue-chip--active' : 'queue-chip--idle'}`;
      chip.textContent = isRunning ? (runningId || '実行中') : '停止中';
      queueStatus.appendChild(label);
      queueStatus.appendChild(dot);
      queueStatus.appendChild(chip);
    }

    async function moveQueueItem(jobId, position, button) {
      const release = setButtonBusy(button, '移動中...');
      try {
        const fd = new FormData();
        fd.set('position', String(position));
        const res = await fetch(`/queue/${jobId}/move`, { method: 'POST', body: fd });
        if (!res.ok) {
          showQueueToast('並び替えに失敗しました', { state: 'error' });
          return;
        }
        await refreshQueue();
      } catch (error) {
        console.error(error);
        showQueueToast('並び替えに失敗しました', { state: 'error' });
      } finally {
        release();
      }
    }

    async function deleteQueueItem(jobId, button) {
      const release = setButtonBusy(button, '削除中...');
      try {
        const res = await fetch(`/queue/${jobId}`, { method: 'DELETE' });
        if (!res.ok) {
          showQueueToast('削除に失敗しました', { state: 'error' });
          return;
        }
        if (editingJobId === jobId) {
          clearEditingState();
        }
        showQueueToast('削除しました', { state: 'success' });
        await refreshQueue();
      } catch (error) {
        console.error(error);
        showQueueToast('削除に失敗しました', { state: 'error' });
      } finally {
        release();
      }
    }

    function createQueueRow(item, index) {
      const row = document.createElement('div');
      row.className = 'row queue-row';
      row.dataset.jobId = item.job_id;
      if (editingJobId && editingJobId === item.job_id) {
        row.classList.add('is-editing');
      }

      const info = document.createElement('div');
      info.className = 'queue-row-info';
      const title = document.createElement('strong');
      title.textContent = item.sheet_name || '(タイトル未取得)';
      const meta = document.createElement('div');
      meta.className = 'queue-row-meta';
      const metaParts = [
        `<code>${item.job_id}</code>`,
        `status: ${item.status || 'queued'}`,
      ];
      if (item.job_type) {
        metaParts.push(item.job_type);
      } else if (item.mode) {
        metaParts.push(item.mode);
      }
      meta.innerHTML = metaParts.map((part) => `<span>${part}</span>`).join('');
      info.appendChild(title);
      info.appendChild(meta);
      row.appendChild(info);

      const actions = document.createElement('div');
      actions.className = 'queue-actions';

      const upBtn = document.createElement('button');
      upBtn.className = 'btn btn-ghost';
      upBtn.textContent = '↑';
      upBtn.addEventListener('click', () => {
        void moveQueueItem(item.job_id, Math.max(0, index - 1), upBtn);
      });

      const downBtn = document.createElement('button');
      downBtn.className = 'btn btn-ghost';
      downBtn.textContent = '↓';
      downBtn.addEventListener('click', () => {
        void moveQueueItem(item.job_id, index + 1, downBtn);
      });

      const editBtn = document.createElement('button');
      editBtn.className = 'btn btn-soft-accent queue-edit-button';
      editBtn.setAttribute('aria-label', '編集');
      editBtn.textContent = '✎';
      editBtn.addEventListener('click', () => {
        void loadQueueJobIntoForm(item.job_id);
      });

      const saveBtn = document.createElement('button');
      saveBtn.className = 'btn btn-primary queue-save-button';
      saveBtn.textContent = '編集を保存';
      saveBtn.addEventListener('click', () => {
        void saveQueueEdit(item.job_id, saveBtn);
      });

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'btn btn-danger queue-delete-button';
      deleteBtn.setAttribute('aria-label', '削除');
      deleteBtn.textContent = '✕';
      deleteBtn.addEventListener('click', () => {
        void deleteQueueItem(item.job_id, deleteBtn);
      });

      actions.appendChild(upBtn);
      actions.appendChild(downBtn);
      actions.appendChild(editBtn);
      actions.appendChild(saveBtn);
      actions.appendChild(deleteBtn);
      row.appendChild(actions);
      return row;
    }

    function renderQueueList(items) {
      if (!queueList) return;
      queueList.innerHTML = '';
      if (!items.length) {
        const empty = document.createElement('p');
        empty.className = 'text-subtle';
        empty.textContent = '待機中のジョブはありません。';
        queueList.appendChild(empty);
        if (editingJobId) {
          clearEditingState();
        }
        return;
      }

      items.forEach((item, index) => {
        queueList.appendChild(createQueueRow(item, index));
      });

      if (editingJobId) {
        const stillExists = items.some((item) => item.job_id === editingJobId);
        if (!stillExists) {
          clearEditingState();
        }
      }
    }

    async function fetchQueueConfig(jobId) {
      const res = await fetch(`/jobs/${jobId}/config`);
      if (!res.ok) {
        throw new Error(`Failed to fetch config (${res.status})`);
      }
      const text = await res.text();
      try {
        return JSON.parse(text);
      } catch (error) {
        console.error('Queue config parse error', error);
        return null;
      }
    }

    async function applyQueueConfig(config) {
      if (!config) return;
      const sheetValue = parseSheetValue(config.sheet_url || config.spreadsheet_url || '');
      if (sheetInput) {
        sheetInput.value = sheetValue;
      }
      resolvedSpreadsheetId = config.spreadsheet_id || sheetValue || '';
      pendingSheetSelection = {
        sheetValue,
        sourceName: config.source_sheet_name || config.sheet_keyword || '',
        outputName: config.output_sheet_name || config.score_sheet_keyword || '',
        sourceId: config.source_sheet_id ?? config.sheet_gid ?? null,
        outputId: config.output_sheet_id ?? config.score_sheet_gid ?? null,
      };
      await handleSheetSet(true);
      updateSheetSelectionInputs();
      updateRunButtonAvailability();
      if (workersInput && config.workers != null) {
        workersInput.value = config.workers;
      }
      if (modelSelect) {
        const targetModel = config.model_name || config.model;
        if (targetModel && modelSelect.querySelector(`option[value="${targetModel}"]`)) {
          modelSelect.value = targetModel;
        }
        refreshCustomSelect(modelSelect);
        maybeLogMissing(detectProvider(modelSelect.value));
      }
      if (fallbackSelect) {
        const fallbackValue = parseSheetValue(config.fallback_model || '');
        if (!fallbackValue || fallbackSelect.querySelector(`option[value="${fallbackValue}"]`)) {
          fallbackSelect.value = fallbackValue;
        }
        refreshCustomSelect(fallbackSelect);
        if (fallbackValue) {
          maybeLogMissing(detectProvider(fallbackValue));
        }
      }
      if (sheetGidInput && config.source_sheet_id != null) {
        sheetGidInput.value = String(config.source_sheet_id);
      }
      if (scoreSheetGidInput && config.output_sheet_id != null) {
        scoreSheetGidInput.value = String(config.output_sheet_id);
      }
      showValidationBanner('info', '読み込んだ設定です。必要に応じて検証を再実行してください。');
    }

    async function loadQueueJobIntoForm(jobId) {
      try {
        const config = await fetchQueueConfig(jobId);
        if (!config) {
          showQueueToast('設定取得に失敗しました', { state: 'error' });
          return;
        }
        await applyQueueConfig(config);
      if (form) {
        form.dataset.editing = jobId;
      }
      editingJobId = jobId;
      renderQueueList(latestQueueItems);
      showQueueToast('フォームに読み込みました。編集後に「編集を保存」を押してください。', { state: 'info' });
    } catch (error) {
      console.error(error);
      showQueueToast('設定取得に失敗しました', { state: 'error' });
    }
    }

    function buildQueueEditFormData() {
      const fd = new FormData();
      const sheetValue = parseSheetValue(sheetInput?.value);
      if (sheetValue) {
        fd.set('sheet_url', sheetValue);
      }
      if (resolvedSpreadsheetId) {
        fd.set('spreadsheet_id', resolvedSpreadsheetId);
      }
      if (sheetKeywordInput && sheetKeywordInput.value) {
        fd.set('source_sheet_name', sheetKeywordInput.value);
        const option = sheetKeywordInput.selectedOptions && sheetKeywordInput.selectedOptions[0];
        if (option && option.dataset.sheetId) {
          fd.set('source_sheet_id', option.dataset.sheetId);
        }
      }
      if (scoreSheetKeywordInput && scoreSheetKeywordInput.value) {
        fd.set('output_sheet_name', scoreSheetKeywordInput.value);
        const option = scoreSheetKeywordInput.selectedOptions && scoreSheetKeywordInput.selectedOptions[0];
        if (option && option.dataset.sheetId) {
          fd.set('output_sheet_id', option.dataset.sheetId);
        }
      }
      if (sheetGidInput && sheetGidInput.value) {
        fd.set('sheet_gid', sheetGidInput.value);
      }
      if (scoreSheetGidInput && scoreSheetGidInput.value) {
        fd.set('score_sheet_gid', scoreSheetGidInput.value);
      }
      if (workersInput && workersInput.value) {
        fd.set('workers', workersInput.value);
      }
      if (modelSelect && modelSelect.value) {
        fd.set('model_name', modelSelect.value);
        fd.set('model_provider', detectProvider(modelSelect.value));
      }
      if (fallbackSelect) {
        const fallbackValue = parseSheetValue(fallbackSelect.value);
        if (fallbackValue) {
          fd.set('fallback_model', fallbackValue);
          fd.set('fallback_provider', detectProvider(fallbackValue));
        } else {
          fd.delete('fallback_model');
          fd.delete('fallback_provider');
        }
      }
      return fd;
    }

    async function saveQueueEdit(jobId, button) {
      if (!form || form.dataset.editing !== jobId) {
        showQueueToast('編集対象を読み込んでください。', { state: 'error' });
        return;
      }
      const fd = buildQueueEditFormData();
      if (!fd.get('sheet_url')) {
        showQueueToast('スプレッドシートURLを入力してください。', { state: 'error' });
        return;
      }
      const release = setButtonBusy(button, '保存中...');
      try {
        const res = await fetch(`/queue/${jobId}/edit`, { method: 'POST', body: fd });
        if (!res.ok) {
          showQueueToast('保存に失敗しました', { state: 'error' });
          return;
        }
        showQueueToast('保存しました', { state: 'success' });
        clearEditingState();
        await refreshQueue();
      } catch (error) {
        console.error(error);
        showQueueToast('保存に失敗しました', { state: 'error' });
      } finally {
        release();
      }
    }

    async function refreshQueue() {
      try {
        const res = await fetch('/queue');
        if (!res.ok) return;
        const data = await res.json();
        const items = Array.isArray(data.items) ? data.items : [];
        latestQueueItems = items;
        renderQueueStatus(data);
        renderQueueList(items);
      } catch (error) {
        console.error(error);
      }
    }

    function finalizeUI() {
      isJobRunning = false;
      updateRunButtonAvailability();
      runButton.textContent = '実行';
      setStopButtonsEnabled(false);
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
      currentProcessId = null;
      syncActionProxies();
    }

    function parseSheetValue(value) {
      return (value || '').trim();
    }

    function showValidationBanner(state, message) {
      if (!validationBanner) return;
      if (!state) {
        validationBanner.removeAttribute('data-state');
        validationBanner.textContent = message || '';
        return;
      }
      validationBanner.setAttribute('data-state', state);
      validationBanner.textContent = message || '';
    }

    function setButtonBusy(button, busyLabel) {
      if (!button) return () => {};
      const original = {
        text: button.textContent,
        disabled: button.disabled,
      };
      button.disabled = true;
      button.setAttribute('aria-busy', 'true');
      if (busyLabel) {
        button.textContent = busyLabel;
      }
      syncActionProxies();
      return () => {
        button.disabled = original.disabled;
        button.textContent = original.text;
        button.removeAttribute('aria-busy');
        syncActionProxies();
      };
    }

    function clearSheetSelections(message = 'Setで読み込んでください') {
      const resetSelect = (selectEl) => {
        if (!selectEl) return;
        const placeholder = message || selectEl.dataset?.placeholder || 'Setで読み込んでください';
        selectEl.innerHTML = `<option value="">${placeholder}</option>`;
        selectEl.disabled = true;
        selectEl.dataset.placeholder = placeholder;
        updateCustomSelectPlaceholder(selectEl, placeholder);
        syncCustomSelectDisabled(selectEl);
        refreshCustomSelect(selectEl);
      };
      resetSelect(sheetKeywordInput);
      resetSelect(scoreSheetKeywordInput);
      resolvedSheets = [];
      if (sheetGidInput) sheetGidInput.value = '';
      if (scoreSheetGidInput) scoreSheetGidInput.value = '';
      updateSheetSelectionInputs();
      updateRunButtonAvailability();
      clearEditingState();
    }

    function updateSheetSelectionInputs() {
      if (sheetKeywordInput && sheetGidInput) {
        const selected = sheetKeywordInput.selectedOptions && sheetKeywordInput.selectedOptions[0];
        sheetGidInput.value = selected && selected.value ? (selected.dataset.sheetId || '') : '';
      }
      if (scoreSheetKeywordInput && scoreSheetGidInput) {
        const selected = scoreSheetKeywordInput.selectedOptions && scoreSheetKeywordInput.selectedOptions[0];
        scoreSheetGidInput.value = selected && selected.value ? (selected.dataset.sheetId || '') : '';
      }
    }

    function applyPendingSheetSelection() {
      if (!pendingSheetSelection) return;
      if (pendingSheetSelection.sheetValue && parseSheetValue(sheetInput?.value) !== pendingSheetSelection.sheetValue) {
        return;
      }
      const selectTarget = (selectEl, name, id) => {
        if (!selectEl || !selectEl.options) return;
        let matched = false;
        if (id != null) {
          const targetId = String(id);
          for (const option of selectEl.options) {
            if (option.dataset && option.dataset.sheetId === targetId) {
              option.selected = true;
              matched = true;
              break;
            }
          }
        }
        if (!matched && name) {
          const lower = name.toLowerCase();
          for (const option of selectEl.options) {
            if ((option.value || '').toLowerCase() === lower) {
              option.selected = true;
              matched = true;
              break;
            }
          }
        }
        if (!matched) {
          selectEl.value = '';
        }
        refreshCustomSelect(selectEl);
      };
      selectTarget(sheetKeywordInput, pendingSheetSelection.sourceName, pendingSheetSelection.sourceId);
      selectTarget(scoreSheetKeywordInput, pendingSheetSelection.outputName, pendingSheetSelection.outputId);
      pendingSheetSelection = null;
      updateSheetSelectionInputs();
      updateRunButtonAvailability();
    }

    function populateSheetOptions(sheets, opts = {}) {
      resolvedSheets = Array.isArray(sheets) ? sheets : [];
      const hasSheets = resolvedSheets.length > 0;
      const placeholderLabel = hasSheets ? '対象シートを選択してください' : 'シートが見つかりません';
      const {
        analysisGid = sheetGidInput?.value,
        scoreGid = scoreSheetGidInput?.value,
        analysisName = sheetKeywordInput?.value,
        scoreName = scoreSheetKeywordInput?.value,
      } = opts;
      const analysisNameLower = (analysisName || '').toLowerCase();
      const scoreNameLower = (scoreName || '').toLowerCase();

      const buildOptions = (selectEl, targetGid) => {
        if (!selectEl) return;
        selectEl.innerHTML = '';
        const placeholder = document.createElement('option');
        placeholder.value = '';
        placeholder.textContent = placeholderLabel;
        selectEl.appendChild(placeholder);
        selectEl.dataset.placeholder = placeholderLabel;
        const targetNameLower = selectEl === sheetKeywordInput ? analysisNameLower : scoreNameLower;
        resolvedSheets.forEach((item) => {
          const option = document.createElement('option');
          option.value = item.sheet_name;
          option.textContent = item.sheet_name;
          option.dataset.sheetId = String(item.sheet_id);
          const matchesGid = targetGid && Number(targetGid) === Number(item.sheet_id);
          const matchesName = !targetGid && targetNameLower && targetNameLower === item.sheet_name.toLowerCase();
          if (matchesGid || matchesName) {
            option.selected = true;
          }
          selectEl.appendChild(option);
        });
        selectEl.disabled = !hasSheets;
        if (!selectEl.disabled && !selectEl.value && selectEl.options.length > 1) {
          selectEl.value = '';
        }
        updateCustomSelectPlaceholder(selectEl, placeholderLabel);
        syncCustomSelectDisabled(selectEl);
        refreshCustomSelect(selectEl);
      };

      buildOptions(sheetKeywordInput, analysisGid);
      buildOptions(scoreSheetKeywordInput, scoreGid);
      updateSheetSelectionInputs();
      if (hasSheets) {
        applyPendingSheetSelection();
      } else {
        pendingSheetSelection = null;
      }
      updateRunButtonAvailability();
    }

    function getSelectedSheet(selectEl) {
      if (!selectEl || selectEl.disabled) return null;
      const name = parseSheetValue(selectEl.value);
      if (!name) return null;
      const option = selectEl.selectedOptions && selectEl.selectedOptions[0];
      const rawId = option?.dataset?.sheetId;
      const parsedId = rawId && rawId !== '' ? Number(rawId) : null;
      const id = typeof parsedId === 'number' && !Number.isNaN(parsedId) ? parsedId : null;
      return { name, id };
    }

    function loadHistory() {
      try {
        return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
      } catch (e) {
        return [];
      }
    }

    function saveHistory(items) {
      localStorage.setItem(HISTORY_KEY, JSON.stringify(items));
    }

    function addToHistory(rawValue, title, status = 'queued', sourceName = '', outputName = '', sourceId = null, outputId = null) {
      const value = parseSheetValue(rawValue);
      if (!value) return;
      const items = loadHistory().filter(entry => entry.value !== value);
      title = (title || '').trim();
      items.unshift({
        value,
        title,
        status,
        sourceName: sourceName || '',
        outputName: outputName || '',
        sourceId: sourceId ?? null,
        outputId: outputId ?? null,
        savedAt: new Date().toISOString(),
      });
      if (items.length > MAX_HISTORY) items.length = MAX_HISTORY;
      saveHistory(items);
      renderHistory();
    }

    function renderHistory() {
      const items = loadHistory();
      historyList.innerHTML = '';
      if (!items.length) {
        historyEmpty.style.display = 'block';
        return;
      }
      historyEmpty.style.display = 'none';
      for (const entry of items) {
        const value = entry.value;
        const title = entry.title || '';
        const li = document.createElement('li');
        const displayTitle = title || '(シート名未取得)';
        const parts = [`状態: ${entry.status || 'queued'}`];
        const detailParts = [];
        if (entry.sourceName) {
          detailParts.push(`元: ${entry.sourceName}`);
        }
        if (entry.outputName) {
          detailParts.push(`出力: ${entry.outputName}`);
        }
        if (detailParts.length) {
          parts.push(detailParts.join(' / '));
        }
        li.innerHTML = `${displayTitle}<br><small class="text-subtle">${parts.join(' | ')}</small>`;
        li.title = value;
        li.addEventListener('click', () => {
          const trimmed = parseSheetValue(value);
          sheetInput.value = trimmed;
          sheetInput.focus();
          clearEditingState();
          pendingSheetSelection = {
            sheetValue: trimmed,
            sourceName: entry.sourceName || '',
            outputName: entry.outputName || '',
            sourceId: entry.sourceId ?? null,
            outputId: entry.outputId ?? null,
          };
          void handleSheetSet(true);
        });
        historyList.appendChild(li);
      }
    }

    async function handleSheetSet(fromHistory = false) {
      if (isSettingSheets) return;
      if (!sheetInput) return;
      const url = parseSheetValue(sheetInput.value);
      if (!url) {
        showValidationBanner('error', 'スプレッドシートURLを入力してください。');
        sheetInput.focus();
        return;
      }
      isSettingSheets = true;
      resolvedSpreadsheetId = '';
      showValidationBanner('info', 'シート一覧を取得中です...');
      clearSheetSelections();
      const releaseButton = setButtonBusy(sheetSetButton, '取得中...');
      try {
        const res = await fetch('/sheets/list', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ spreadsheet_url: url }),
        });
        let data = null;
        try {
          data = await res.json();
        } catch (err) {
          data = null;
        }
        if (!res.ok || !data || !data.ok) {
          const message = (data && data.message) || `シート一覧の取得に失敗しました。（status ${res.status}）`;
          throw new Error(message);
        }
        resolvedSpreadsheetId = data.spreadsheet_id || url;
        populateSheetOptions(Array.isArray(data.sheets) ? data.sheets : []);
        showValidationBanner('success', 'シート一覧を読み込みました。対象シートを選択してください。');
        if (!fromHistory) {
          log('-> シート一覧を取得しました。');
        }
      } catch (error) {
        populateSheetOptions([]);
        pendingSheetSelection = null;
        showValidationBanner('error', `シート一覧の取得に失敗しました: ${error instanceof Error ? error.message : error}`);
        log(`-> シート一覧の取得に失敗: ${error}`, true);
      } finally {
        releaseButton();
        isSettingSheets = false;
        updateRunButtonAvailability();
      }
    }

    renderHistory();
    showValidationBanner('info', 'Set ボタンでシート一覧を読み込み、対象シートを選択してください。');
    updateRunButtonAvailability();

    refreshKeyStatus(false);
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        refreshKeyStatus(false);
        void refreshQueue();
        if (!queueRefreshTimer) {
          queueRefreshTimer = window.setInterval(refreshQueue, 5000);
        }
      } else if (queueRefreshTimer) {
        clearInterval(queueRefreshTimer);
        queueRefreshTimer = null;
      }
    });

    if (queueStartButton) {
      queueStartButton.addEventListener('click', async () => {
        const release = setButtonBusy(queueStartButton, '起動中...');
        try {
          const res = await fetch('/queue/start', { method: 'POST' });
          if (!res.ok) {
            showQueueToast('キュー起動に失敗しました', { state: 'error' });
            return;
          }
          showQueueToast('キューを起動しました', { state: 'success' });
          await refreshQueue();
        } catch (error) {
          console.error(error);
          showQueueToast('キュー起動に失敗しました', { state: 'error' });
        } finally {
          release();
        }
      });
    }

    void refreshQueue();
    queueRefreshTimer = window.setInterval(refreshQueue, 5000);

    window.addEventListener('beforeunload', () => {
      if (queueRefreshTimer) {
        clearInterval(queueRefreshTimer);
      }
    });

    if (sheetSetButton) {
      sheetSetButton.addEventListener('click', () => {
        void handleSheetSet(false);
      });
    }

    if (sheetInput) {
      sheetInput.addEventListener('input', () => {
        resolvedSpreadsheetId = '';
        pendingSheetSelection = null;
        clearSheetSelections();
        const trimmed = parseSheetValue(sheetInput.value);
        if (trimmed) {
          showValidationBanner('info', 'Set で最新のシート一覧を取得してください。');
        } else {
          showValidationBanner('info', 'Set ボタンでシート一覧を読み込み、対象シートを選択してください。');
        }
        clearEditingState();
      });
    }

    if (sheetKeywordInput) {
      sheetKeywordInput.addEventListener('change', () => {
        updateSheetSelectionInputs();
        updateRunButtonAvailability();
        refreshCustomSelect(sheetKeywordInput);
      });
    }

    if (scoreSheetKeywordInput) {
      scoreSheetKeywordInput.addEventListener('change', () => {
        updateSheetSelectionInputs();
        updateRunButtonAvailability();
        refreshCustomSelect(scoreSheetKeywordInput);
      });
    }

    if (fallbackSelect) {
      fallbackSelect.addEventListener('change', () => {
        refreshCustomSelect(fallbackSelect);
        const fallbackValue = parseSheetValue(fallbackSelect.value);
        if (!fallbackValue) return;
        const provider = detectProvider(fallbackValue);
        maybeLogMissing(provider);
      });
    }

    if (refreshQueueButton) {
      refreshQueueButton.addEventListener('click', () => {
        void refreshQueue();
        renderHistory();
      });
    }

    if (modelSelect) {
      modelSelect.addEventListener('change', () => {
        updateRunButtonAvailability();
        const provider = detectProvider(modelSelect.value);
        maybeLogMissing(provider);
        const fallbackValue = fallbackSelect ? parseSheetValue(fallbackSelect.value) : '';
        if (fallbackValue) {
          maybeLogMissing(detectProvider(fallbackValue));
        }
      });
    }

    async function handleStopClick() {
      if (!currentProcessId) {
        log('-> 停止対象のジョブがありません。', true);
        return;
      }
      setStopButtonsEnabled(false);
      log('-> 停止信号を送信します...');
      try {
        await fetch('/stop-analysis', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ process_id: currentProcessId }),
        });
        log('-> 停止信号を送信しました。');
      } catch (error) {
        log(`-> 停止リクエストでエラー: ${error}`, true);
      }
    }

    if (stopButton) {
      stopButton.addEventListener('click', () => {
        void handleStopClick();
      });
    }

    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      if (!modelSelect) {
        log('-> モデル選択が利用できません。ページを再読み込みしてください。', true);
        runButton.disabled = true;
        syncActionProxies();
        return;
      }

      const provider = detectProvider(modelSelect.value);
      if (!keyStatus[provider]) {
        const message =
          provider === 'gemini'
            ? 'Gemini モデルを使用するには Gemini APIキーが必要です。左メニューの「API」で登録してください。'
            : 'GPT 系モデルを使用するには OpenAI APIキーが必要です。左メニューの「API」で登録してください。';
        log(`-> ${message}`, true);
        updateRunButtonAvailability();
        return;
      }

      const sheetValue = parseSheetValue(sheetInput?.value);
      if (!sheetValue) {
        showValidationBanner('error', 'スプレッドシートURLを入力してください。');
        log('-> スプレッドシートURLが未入力です。', true);
        updateRunButtonAvailability();
        return;
      }

      const sourceSheet = getSelectedSheet(sheetKeywordInput);
      if (!sourceSheet) {
        showValidationBanner('error', '分析テキスト シートを選択してください。');
        log('-> 分析テキスト シートを選択してください。', true);
        updateRunButtonAvailability();
        return;
      }

      const outputSheet = getSelectedSheet(scoreSheetKeywordInput);
      if (!outputSheet) {
        showValidationBanner('error', 'コメント出力 シートを選択してください。');
        log('-> コメント出力 シートを選択してください。', true);
        updateRunButtonAvailability();
        return;
      }

      let fallbackModel = fallbackSelect ? parseSheetValue(fallbackSelect.value) : '';
      let fallbackProvider = fallbackModel ? detectProvider(fallbackModel) : null;
      if (fallbackModel && (!fallbackProvider || !keyStatus[fallbackProvider])) {
        log(`-> フォールバックモデル (${fallbackModel}) のAPIキーが設定されていないため、フォールバックを無効化します。`, true);
        fallbackModel = '';
        fallbackProvider = null;
      }

      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }

      const payload = {
        sheet_url: sheetValue,
        workers: document.getElementById('workers').value,
        model_name: modelSelect.value,
        model_provider: provider,
        source_sheet_name: sourceSheet.name,
        source_sheet_id: sourceSheet.id,
        output_sheet_name: outputSheet.name,
        output_sheet_id: outputSheet.id,
        fallback_model: fallbackModel || null,
        fallback_provider: fallbackProvider,
      };
      if (resolvedSpreadsheetId) {
        payload.spreadsheet_id = resolvedSpreadsheetId;
      }

      logContainer.innerHTML = '';
      log('-> AnyAICommentEnhancer を開始します...');
      isJobRunning = true;
      updateRunButtonAvailability();
      runButton.textContent = '実行中...';
      setStopButtonsEnabled(true);
      syncActionProxies();

      try {
        const resp = await loadingOverlay.run(() =>
          fetch('/run-comment-enhancer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          })
        );
        const result = await resp.json();
        if (!resp.ok) {
          const errorMessage = result.error || result.detail || result.message || 'Unknown error';
          log(`Error: ${errorMessage}`, true);
          finalizeUI();
          return;
        }

        currentProcessId = result.process_id;
        const jobSheetUrl = result.sheet_url || payload.sheet_url;
        const jobTitle = result.sheet_title;
        const jobParams = { ...payload };
        addToHistory(jobSheetUrl, jobTitle, 'queued', sourceSheet.name, outputSheet.name, sourceSheet.id, outputSheet.id);
        log(`-> Process ID: ${currentProcessId}`);

        await refreshQueue();
        eventSource = new EventSource(`/stream-logs?process_id=${currentProcessId}`);
        eventSource.onmessage = (evt) => {
          log(evt.data);
        };
        eventSource.addEventListener('queue', (evt) => {
          try {
            const queuePayload = JSON.parse(evt.data);
            const status = queuePayload.status || 'queued';
            log(`-> ジョブ ${queuePayload.process_id} の状態: ${status}`);
            void refreshQueue();
            if (queuePayload.process_id === currentProcessId) {
              const params = queuePayload.params || {};
              addToHistory(
                queuePayload.sheet_url || jobSheetUrl,
                queuePayload.sheet_title || jobTitle,
                status,
                params.source_sheet_name || jobParams.source_sheet_name,
                params.output_sheet_name || jobParams.output_sheet_name,
                params.source_sheet_id ?? jobParams.source_sheet_id ?? null,
                params.output_sheet_id ?? jobParams.output_sheet_id ?? null,
              );
              renderHistory();
            }
          } catch (error) {
            log(`-> キュー情報の解析に失敗: ${error}`, true);
          }
        });
        eventSource.addEventListener('error', (evt) => {
          if (evt.data) {
            log(`-> ${evt.data}`, true);
          } else {
            log('-> ログストリームが切断されました。', true);
          }
          finalizeUI();
          refreshKeyStatus(false);
        });
        eventSource.addEventListener('complete', (evt) => {
          log(`-> ${evt.data}`);
          addToHistory(
            jobSheetUrl,
            jobTitle,
            'completed',
            jobParams.source_sheet_name,
            jobParams.output_sheet_name,
            jobParams.source_sheet_id ?? null,
            jobParams.output_sheet_id ?? null,
          );
          void refreshQueue();
          renderHistory();
          finalizeUI();
        });
      } catch (error) {
        log(`Network or server error: ${error}`, true);
        refreshKeyStatus(false);
        finalizeUI();
      }
    });
  </script>
</body>
</html>

from __future__ import annotations

import json
import sys
from dataclasses import dataclass
from functools import lru_cache
from pathlib import Path
from typing import Iterable, List, Optional

import polars as po

SSR_PACKAGE_ROOT = Path(__file__).resolve().parents[2] / "semantic-similarity-rating-main"
if SSR_PACKAGE_ROOT.exists():
    sys.path.append(str(SSR_PACKAGE_ROOT))

try:
    from semantic_similarity_rating import ResponseRater  # type: ignore
except ImportError:  # pragma: no cover - optional dependency
    ResponseRater = None  # type: ignore[misc, assignment]


class SSRMappingError(RuntimeError):
    """Raised when SSR mapping cannot be performed."""


@dataclass
class ReferenceConfig:
    reference_path: Path
    embeddings_column: str = "embedding"
    model_name: str = "sentence-transformers/all-MiniLM-L6-v2"
    device: Optional[str] = None


def _ensure_response_rater(df: po.DataFrame, *, embeddings_column: str, model_name: str, device: Optional[str]):
    if ResponseRater is None:
        raise SSRMappingError(
            "semantic-similarity-rating package is unavailable. "
            "Ensure `semantic-similarity-rating-main` is present or installed."
        )
    return ResponseRater(
        df_reference_sentences=df,
        embeddings_column=embeddings_column,
        model_name=model_name,
        device=device,
    )


def _load_reference_dataframe(path: Path) -> po.DataFrame:
    if not path.exists():
        raise SSRMappingError(f"Reference file not found: {path}")
    ext = path.suffix.lower()
    try:
        if ext in {".json", ".jsonl"}:
            text = path.read_text(encoding="utf-8")
            if ext == ".jsonl":
                records = [json.loads(line) for line in text.splitlines() if line.strip()]
            else:
                payload = json.loads(text)
                records = payload if isinstance(payload, list) else payload.get("records", [])
            return po.DataFrame(records)
        if ext in {".parquet", ".pq"}:
            return po.read_parquet(path)
        if ext in {".csv"}:
            return po.read_csv(path)
    except Exception as exc:  # noqa: BLE001
        raise SSRMappingError(f"Failed to load reference sentences from {path}: {exc}") from exc
    raise SSRMappingError(f"Unsupported reference file extension: {path.suffix}")


@lru_cache(maxsize=4)
def _cached_rater(
    reference_path: Path,
    embeddings_column: str,
    model_name: str,
    device: Optional[str],
):
    df = _load_reference_dataframe(reference_path)
    return _ensure_response_rater(
        df=df,
        embeddings_column=embeddings_column,
        model_name=model_name,
        device=device,
    )


def map_responses_to_pmfs(
    responses: Iterable[str],
    *,
    reference_set: str,
    config: ReferenceConfig,
    temperature: float = 1.0,
    epsilon: float = 0.0,
) -> List[List[float]]:
    """Convert free-text responses into Likert PMFs via semantic similarity.

    Parameters
    ----------
    responses:
        Iterable of response strings generated by LLMs.
    reference_set:
        Identifier of the reference sentence set (e.g., "purchase_intent_v1").
    config:
        Reference configuration describing where to load the reference sentences and which model to use.
    temperature:
        Temperature applied to the resulting PMFs. 1.0 keeps original distribution.
    epsilon:
        Optional smoothing factor for low-similarity responses.

    Returns
    -------
    list[list[float]]
        A list of PMFs (each PMF is a list of floats summing to 1).
    """
    if not responses:
        return []

    rater = _cached_rater(
        config.reference_path.resolve(),
        config.embeddings_column,
        config.model_name,
        config.device,
    )
    try:
        pmfs = rater.get_response_pmfs(
            reference_set_id=reference_set,
            llm_responses=list(responses),
            temperature=temperature,
            epsilon=epsilon,
        )
    except Exception as exc:  # noqa: BLE001
        raise SSRMappingError(f"Failed to project responses onto Likert PMFs: {exc}") from exc
    return [pmf.tolist() for pmf in pmfs]
